<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Starting Five - Basketball Card Game</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial Black', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            padding: 20px;
            min-height: 100vh;
        }

        .game-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .game-info {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .game-info h3 {
            margin-bottom: 10px;
        }

        .players-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            max-width: 100%;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (min-width: 800px) {
            .players-container {
                grid-template-columns: repeat(2, 1fr);
            }
        }


        .player-area {
            background: rgba(255,255,255,0.05);
            border: 3px solid rgba(255,255,255,0.2);
            border-radius: 15px;
            padding: 20px;
            min-width: 350px;
            width: 100%;
        }

        .player-area.active {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .player-area.winner {
            border-color: #FFD700;
            box-shadow: 0 0 30px rgba(255,215,0,0.9), 0 0 60px rgba(255,215,0,0.6);
            animation: winnerPulse 2s ease-in-out infinite;
        }

        @keyframes winnerPulse {
            0%, 100% {
                box-shadow: 0 0 30px rgba(255,215,0,0.9), 0 0 60px rgba(255,215,0,0.6);
            }
            50% {
                box-shadow: 0 0 40px rgba(255,215,0,1), 0 0 80px rgba(255,215,0,0.8);
            }
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }

        .player-name {
            font-size: 1.5em;
            font-weight: bold;
            min-width: 180px;
        }

        .team-ovr {
            font-size: 2em;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .lineup {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .position-slot {
            background: rgba(0,0,0,0.3);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 10px 5px;
            text-align: center;
            min-height: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .position-label {
            font-size: 0.8em;
            margin-bottom: 5px;
            color: #aaa;
        }

        .card {
            width: 100%;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .card:hover {
            transform: scale(1.05);
        }

        .card-position {
            font-size: 0.7em;
            margin-bottom: 3px;
        }

        .card-name {
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .card-ovr {
            font-size: 1.5em;
            font-weight: bold;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px auto;
        }

        .card-rank {
            font-size: 0.9em;
            font-weight: bold;
        }

        .hand {
            margin-top: 15px;
        }

        .hand-title {
            font-size: 1.1em;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .hand-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
        }

        .hand-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .hand-card:hover {
            transform: translateY(-5px);
            border-color: #ffd700;
        }

        .hand-card.selected {
            border-color: #00ff00;
            background: rgba(0,255,0,0.2);
        }

        .controls {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255,215,0,0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 15px;
            max-width: 1200px;
            width: 90%;
            border: 3px solid #ffd700;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #ffd700;
        }

        .message {
            background: rgba(255,215,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #ffd700;
        }

        .bonus-info {
            font-size: 0.9em;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
        }

        .setup-area {
            text-align: center;
            padding: 40px;
        }
        
        .player-count-btn {
            width: 60px;
            height: 60px;
            font-size: 1.5em;
            margin: 5px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #ffd700;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .player-count-btn:hover:not(:disabled) {
            background: rgba(255,215,0,0.3);
            transform: scale(1.1);
        }
        
        .player-count-btn.selected {
            background: #ffd700;
            color: black;
            font-weight: bold;
        }
        
        .player-count-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }


        select {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            margin: 10px;
        }

        .burn-pile {
            background: rgba(255,0,0,0.2);
            border: 2px solid rgba(255,0,0,0.5);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .instructions {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        @keyframes cardDraw {
            0% {
                transform: translateY(-50px) scale(0.5);
                opacity: 0;
            }
            50% {
                transform: translateY(-25px) scale(0.75);
                opacity: 0.5;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes cardBurn {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.2) rotate(10deg);
                opacity: 0.5;
            }
            100% {
                transform: scale(0) rotate(20deg);
                opacity: 0;
            }
        }

        @keyframes cardLockIn {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0px rgba(255, 215, 0, 0);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
            }
        }

        @keyframes cardReceive {
            0% {
                transform: translateX(-100px) scale(0.8);
                opacity: 0;
            }
            60% {
                transform: translateX(10px) scale(1.1);
                opacity: 1;
            }
            100% {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        .card-draw-animation {
            animation: cardDraw 0.5s ease-out;
        }

        .card-burn-animation {
            animation: cardBurn 0.5s ease-in forwards;
        }

        .card-lockin-animation {
            animation: cardLockIn 0.8s ease-out;
        }

        .card-receive-animation {
            animation: cardReceive 0.6s ease-out;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üèÄ STARTING FIVE üèÄ</h1>

        <div id="setupScreen" class="setup-area">
            <p style="font-size: 1.5em; margin-bottom: 50px; font-weight: bold;">The Ultimate NBA Card Draft Game</p>
            
            <!-- Step 1: Mode Selection -->
            <div id="modeSelection">
                <h2 style="margin-bottom: 40px; font-size: 2em;">Choose Game Mode</h2>
                <button onclick="selectMode('local')" style="width: 350px; height: 90px; font-size: 1.6em; margin: 20px; background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); border: none; border-radius: 15px; color: white; cursor: pointer; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                    üè† Same Device
                </button>
                <br>
                <button onclick="selectMode('online')" style="width: 350px; height: 90px; font-size: 1.6em; margin: 20px; background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); border: none; border-radius: 15px; color: white; cursor: pointer; font-weight: bold; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
                    üåê Online
                </button>
            </div>
            
            <!-- Step 2: Player Selection -->
            <div id="playerSelection" style="display: none;">
                <h2 style="margin-bottom: 40px; font-size: 2em;">Select Players</h2>
                <div style="margin-bottom: 40px;">
                    <p style="font-size: 1.3em; margin-bottom: 15px;"><strong>Human Players:</strong></p>
                    <div id="humanPlayerButtons">
                        <button class="player-count-btn" onclick="setHumanPlayers(1)">1</button>
                        <button class="player-count-btn selected" onclick="setHumanPlayers(2)">2</button>
                        <button class="player-count-btn" onclick="setHumanPlayers(3)">3</button>
                        <button class="player-count-btn" onclick="setHumanPlayers(4)">4</button>
                        <button class="player-count-btn" onclick="setHumanPlayers(5)">5</button>
                        <button class="player-count-btn" onclick="setHumanPlayers(6)">6</button>
                    </div>
                </div>
                <div style="margin-bottom: 40px;">
                    <p style="font-size: 1.3em; margin-bottom: 15px;"><strong>AI Opponents:</strong></p>
                    <div id="aiPlayerButtons">
                        <button class="player-count-btn selected" onclick="setAIPlayers(0)">0</button>
                        <button class="player-count-btn" onclick="setAIPlayers(1)">1</button>
                        <button class="player-count-btn" onclick="setAIPlayers(2)">2</button>
                        <button class="player-count-btn" onclick="setAIPlayers(3)">3</button>
                        <button class="player-count-btn" onclick="setAIPlayers(4)">4</button>
                        <button class="player-count-btn" onclick="setAIPlayers(5)">5</button>
                    </div>
                </div>
                <p style="font-size: 1.1em; color: #aaa; margin-bottom: 30px;">Maximum 6 total players (Human + AI)</p>
                <div style="margin-top: 40px;">
                    <button onclick="backToModeSelection()" style="margin-right: 15px; padding: 15px 35px; font-size: 1.3em; border-radius: 8px;">‚Üê Back</button>
                    <button onclick="confirmPlayerSelection()" id="confirmPlayersBtn" style="padding: 15px 35px; font-size: 1.3em; background: #4CAF50; color: white; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">Start Game ‚Üí</button>
                </div>
            </div>
            
            <!-- Step 3: Online Room (online mode only) -->
            <div id="onlineRoom" style="display: none;">
                <h2 style="margin-bottom: 40px; font-size: 2em;">Online Multiplayer</h2>
                <div id="roomCreation">
                    <p style="margin: 25px 0; font-size: 1.3em;">Enter your name:</p>
                    <input type="text" id="playerName" placeholder="Your Name" style="padding: 15px; font-size: 1.2em; border-radius: 8px; margin: 15px; min-width: 250px; border: 2px solid #555;">
                    <br>
                    <button onclick="createRoom()" style="margin: 15px; padding: 15px 35px; font-size: 1.3em; border-radius: 8px; background: #4CAF50; color: white; font-weight: bold; border: none; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">Create Room</button>
                    <p style="margin: 25px 0; font-size: 1.3em;">OR</p>
                    <input type="text" id="roomCode" placeholder="Enter Room Code" style="padding: 15px; font-size: 1.2em; border-radius: 8px; margin: 15px; min-width: 250px; border: 2px solid #555; text-transform: uppercase;">
                    <br>
                    <button onclick="joinRoom()" style="margin: 15px; padding: 15px 35px; font-size: 1.3em; border-radius: 8px; background: #2196F3; color: white; font-weight: bold; border: none; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">Join Room</button>
                </div>
                
                <div id="roomLobby" style="display: none;">
                    <h2 style="font-size: 1.8em;">Room Code: <span id="displayRoomCode" style="color: #ffd700; font-size: 2em;"></span></h2>
                    <p style="margin: 15px 0; font-size: 1.2em;">Share this code with other players!</p>
                    <h3 style="margin-top: 30px; font-size: 1.5em;">Players in Lobby:</h3>
                    <div id="lobbyPlayers" style="margin: 25px 0; font-size: 1.2em;"></div>
                    <button id="startOnlineGame" onclick="startOnlineGame()" style="display: none; margin: 15px; padding: 15px 40px; font-size: 1.3em; border-radius: 8px; background: #4CAF50; color: white; font-weight: bold; border: none; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">Start Game</button>
                    <button onclick="leaveRoom()" style="margin: 15px; padding: 15px 35px; font-size: 1.3em; border-radius: 8px; background: #f44336; color: white; font-weight: bold; border: none; cursor: pointer;">Leave Room</button>
                </div>
                <div style="margin-top: 40px;">
                    <button onclick="backToModeSelection()" style="padding: 15px 35px; font-size: 1.3em; border-radius: 8px;">‚Üê Back</button>
                </div>
            </div>
        </div>

        <div id="gameScreen" style="display: none;">
            <div class="instructions" style="position: relative;">
                <div style="position: absolute; top: 10px; right: 10px; display: flex; gap: 10px;">
                    <button onclick="showInstructions()" style="padding: 10px 15px; background: #32CD32; border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 1.2em;" title="Game Instructions">üìñ</button>
                    <button onclick="showLineupReview()" style="padding: 10px 15px; background: #9370DB; border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 1.2em;" title="Review All Lineups">üë•</button>
                    <button onclick="showCardIndex()" style="padding: 10px 15px; background: #4169E1; border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 1.2em;" title="Card Index">üìã</button>
                </div>
                <strong style="font-size: 1.3em;">Current Phase:</strong> <span id="phaseText" style="font-size: 1.3em;">Setup</span><br>
                <span id="instructionText" style="font-size: 1.2em; display: block; margin-top: 8px;">Choose your captain and place it face-down.</span>
            </div>

            <div class="game-info">
                <h3 id="turnInfo" style="font-size: 1.4em;">Game Starting...</h3>
                <div class="message" id="messageBox" style="font-size: 1.2em;"></div>
            </div>

            <div class="controls">
                <div id="controlsContent"></div>
            </div>

            <div class="players-container" id="playersContainer"></div>

            <div class="burn-pile">
                <h3>Burn Pile (Last 10 Cards)</h3>
                <div id="burnPile" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-top: 10px;"></div>
            </div>
        </div>

        <div id="modal" class="modal">
            <div class="modal-content">
                <h2 id="modalTitle">Modal Title</h2>
                <div id="modalBody"></div>
                <button onclick="closeModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Online multiplayer state
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAybrLVNSNivAejRoZN9LsnXXM75r4Zc8o",
            authDomain: "starting-five-9a397.firebaseapp.com",
            databaseURL: "https://starting-five-9a397-default-rtdb.firebaseio.com",
            projectId: "starting-five-9a397",
            storageBucket: "starting-five-9a397.firebasestorage.app",
            messagingSenderId: "561805072305",
            appId: "1:561805072305:web:4f0298c07e144cf6e14f90",
            measurementId: "G-5JLL9T956M"
        };

        // Initialize Firebase (will be available when deployed)
        let firebaseApp = null;
        let database = null;
        
        try {
            if (typeof firebase !== 'undefined') {
                firebaseApp = firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                console.log('Firebase initialized successfully!');
            }
        } catch (error) {
            console.log('Firebase not available - using local mode only');
        }
        
        let onlineGame = {
            enabled: false,
            roomCode: null,
            playerId: null,
            playerName: null,
            isHost: false
        };

        function createRoom() {
            if (!database) {
                alert('Firebase is not initialized. Please deploy this file to a web server to use online multiplayer.\n\nFor local testing, use "Same Device" mode.');
                return;
            }
            
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                alert('Please enter your name!');
                return;
            }
            
            // Generate 6-character room code
            const roomCode = Math.random().toString(36).substring(2, 8).toUpperCase();
            onlineGame.roomCode = roomCode;
            onlineGame.playerName = playerName;
            onlineGame.playerId = Date.now().toString();
            onlineGame.isHost = true;
            onlineGame.enabled = true;
            
            // Create room in database
            database.ref(`rooms/${roomCode}`).set({
                host: onlineGame.playerId,
                players: {
                    [onlineGame.playerId]: {
                        name: playerName,
                        ready: false
                    }
                },
                gameStarted: false,
                createdAt: Date.now()
            });
            
            document.getElementById('roomCreation').style.display = 'none';
            document.getElementById('roomLobby').style.display = 'block';
            document.getElementById('displayRoomCode').textContent = roomCode;
            
            // Listen for players joining
            database.ref(`rooms/${roomCode}/players`).on('value', (snapshot) => {
                const players = snapshot.val();
                const lobbyDiv = document.getElementById('lobbyPlayers');
                lobbyDiv.innerHTML = '';
                
                Object.entries(players).forEach(([id, player]) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 10px; margin: 5px 0; background: rgba(255,255,255,0.1); border-radius: 5px;';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = player.name + (id === onlineGame.playerId ? ' (You)' : '');
                    playerDiv.appendChild(nameSpan);
                    
                    // Show kick button if host and not yourself
                    if (onlineGame.isHost && id !== onlineGame.playerId) {
                        const kickBtn = document.createElement('button');
                        kickBtn.textContent = '‚ùå Kick';
                        kickBtn.style.cssText = 'padding: 5px 15px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9em;';
                        kickBtn.onclick = () => kickPlayer(id);
                        playerDiv.appendChild(kickBtn);
                    }
                    
                    lobbyDiv.appendChild(playerDiv);
                });
                
                // Show start button if host and at least 2 players
                if (onlineGame.isHost && Object.keys(players).length >= 2) {
                    document.getElementById('startOnlineGame').style.display = 'inline-block';
                }
            });
        }
        
        function kickPlayer(playerId) {
            if (!onlineGame.isHost || !database || !onlineGame.roomCode) return;
            
            // Remove player from room
            database.ref(`rooms/${onlineGame.roomCode}/players/${playerId}`).remove();
        }

        function joinRoom() {
            if (!database) {
                alert('Firebase is not initialized. Please deploy this file to a web server to use online multiplayer.\n\nFor local testing, use "Same Device" mode.');
                return;
            }
            
            const playerName = document.getElementById('playerName').value.trim();
            const roomCode = document.getElementById('roomCode').value.trim().toUpperCase();
            
            if (!playerName || !roomCode) {
                alert('Please enter your name and room code!');
                return;
            }
            
            // Check if room exists
            database.ref(`rooms/${roomCode}`).once('value').then((snapshot) => {
                if (!snapshot.exists()) {
                    alert('Room not found! Please check the room code.');
                    return;
                }
                
                const room = snapshot.val();
                if (room.gameStarted) {
                    alert('Game already in progress!');
                    return;
                }
                
                onlineGame.roomCode = roomCode;
                onlineGame.playerName = playerName;
                onlineGame.playerId = Date.now().toString();
                onlineGame.isHost = false;
                onlineGame.enabled = true;
                
                // Add player to room
                database.ref(`rooms/${roomCode}/players/${onlineGame.playerId}`).set({
                    name: playerName,
                    ready: false
                });
                
                document.getElementById('roomCreation').style.display = 'none';
                document.getElementById('roomLobby').style.display = 'block';
                document.getElementById('displayRoomCode').textContent = roomCode;
                
                // Listen for players
                database.ref(`rooms/${roomCode}/players`).on('value', (snapshot) => {
                    const players = snapshot.val();
                    
                    // Check if you've been kicked
                    if (players && !players[onlineGame.playerId]) {
                        alert('You have been removed from the room by the host.');
                        leaveRoom();
                        return;
                    }
                    
                    const lobbyDiv = document.getElementById('lobbyPlayers');
                    lobbyDiv.innerHTML = '';
                    
                    Object.entries(players).forEach(([id, player]) => {
                        const playerDiv = document.createElement('div');
                        playerDiv.style.cssText = 'padding: 10px; margin: 5px 0; background: rgba(255,255,255,0.1); border-radius: 5px;';
                        playerDiv.textContent = player.name + (id === onlineGame.playerId ? ' (You)' : '');
                        lobbyDiv.appendChild(playerDiv);
                    });
                });
                
                // Listen for game start
                database.ref(`rooms/${roomCode}/gameStarted`).on('value', (snapshot) => {
                    if (snapshot.val()) {
                        startOnlineGame();
                    }
                });
            });
        }

        function leaveRoom() {
            if (database && onlineGame.roomCode) {
                // Remove player from room
                database.ref(`rooms/${onlineGame.roomCode}/players/${onlineGame.playerId}`).remove();
            }
            
            onlineGame.enabled = false;
            onlineGame.roomCode = null;
            onlineGame.playerId = null;
            onlineGame.isHost = false;
            
            document.getElementById('roomLobby').style.display = 'none';
            document.getElementById('roomCreation').style.display = 'block';
        }

        function startOnlineGame() {
            if (onlineGame.isHost && database && onlineGame.roomCode) {
                // Mark game as started
                database.ref(`rooms/${onlineGame.roomCode}/gameStarted`).set(true);
            }
            
            // Get player list from Firebase to determine player order
            if (database && onlineGame.roomCode) {
                database.ref(`rooms/${onlineGame.roomCode}/players`).once('value').then((snapshot) => {
                    const players = snapshot.val();
                    const playerIds = Object.keys(players);
                    
                    // Find this player's index in the room
                    const myIndex = playerIds.indexOf(onlineGame.playerId);
                    
                    // Set up game with correct player count
                    gameState.menuState.humanPlayers = playerIds.length;
                    gameState.menuState.aiPlayers = 0;
                    
                    // Store the mapping of game IDs to Firebase IDs
                    onlineGame.playerMapping = {};
                    playerIds.forEach((id, index) => {
                        onlineGame.playerMapping[index] = id;
                    });
                    
                    // Store this player's game ID
                    onlineGame.gamePlayerId = myIndex;
                    
                    startGame();
                    
                    // Set up game state sync
                    setupOnlineSync();
                });
            } else {
                // Fallback for local testing
                gameState.menuState.humanPlayers = 2;
                gameState.menuState.aiPlayers = 0;
                startGame();
            }
        }
        
        function setupOnlineSync() {
            if (!database || !onlineGame.roomCode) return;
            
            const gameRef = database.ref(`rooms/${onlineGame.roomCode}/gameState`);
            
            // If host, initialize the game state
            if (onlineGame.isHost) {
                // Shuffle deck and store it
                const shuffledDeck = [...CARDS];
                shuffleArray(shuffledDeck);
                
                // Store deck as ranks (smaller data)
                const deckRanks = shuffledDeck.map(c => c.rank);
                
                gameRef.set({
                    deck: deckRanks,
                    phase: 'captainSelection',
                    currentPlayerIndex: 0,
                    captains: {},
                    hands: {},
                    lineups: {},
                    burnPile: [],
                    hasAsked: false,
                    waitingForBurn: null,
                    selectedPosition: null,
                    targetPlayer: null,
                    lastAction: null
                });
                
                // Deal cards to players
                const numPlayers = gameState.players.length;
                const hands = {};
                for (let i = 0; i < numPlayers; i++) {
                    hands[i] = [];
                }
                
                // Deal 8 cards to each player
                let deckIndex = 0;
                for (let cardNum = 0; cardNum < 8; cardNum++) {
                    for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
                        hands[playerIndex].push(deckRanks[deckIndex]);
                        deckIndex++;
                    }
                }
                
                gameRef.child('hands').set(hands);
                gameRef.child('deckIndex').set(deckIndex);
            }
            
            // Listen for all game state changes
            gameRef.on('value', (snapshot) => {
                const syncedState = snapshot.val();
                if (!syncedState) return;
                
                syncGameStateFromFirebase(syncedState);
            });
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function syncGameStateFromFirebase(syncedState) {
            // Update deck
            if (syncedState.deck) {
                gameState.deck = syncedState.deck.slice(syncedState.deckIndex || 0).map(rank => 
                    CARDS.find(c => c.rank === rank)
                );
            }
            
            // Update hands
            if (syncedState.hands) {
                Object.entries(syncedState.hands).forEach(([playerIndex, handRanks]) => {
                    const player = gameState.players[parseInt(playerIndex)];
                    if (player) {
                        player.hand = handRanks.map(rank => CARDS.find(c => c.rank === rank));
                    }
                });
            }
            
            // Update captains
            if (syncedState.captains) {
                Object.entries(syncedState.captains).forEach(([playerIndex, captainData]) => {
                    const player = gameState.players[parseInt(playerIndex)];
                    if (player && captainData) {
                        const captain = CARDS.find(c => c.rank === captainData.rank);
                        if (captain) {
                            player.captain = captain;
                            if (captainData.position && !player.lineup[captainData.position]) {
                                player.lineup[captainData.position] = captain;
                                player.captainHidden = true;
                                // Remove from hand
                                player.hand = player.hand.filter(c => c.rank !== captain.rank);
                            }
                        }
                    }
                });
            }
            
            // Update lineups
            if (syncedState.lineups) {
                Object.entries(syncedState.lineups).forEach(([playerIndex, lineup]) => {
                    const player = gameState.players[parseInt(playerIndex)];
                    if (player && lineup) {
                        Object.entries(lineup).forEach(([pos, cardRank]) => {
                            if (cardRank) {
                                const card = CARDS.find(c => c.rank === cardRank);
                                if (card && !player.lineup[pos]) {
                                    player.lineup[pos] = card;
                                    // Remove from hand if present
                                    player.hand = player.hand.filter(c => c.rank !== cardRank);
                                }
                            }
                        });
                    }
                });
            }
            
            // Update burn pile
            if (syncedState.burnPile) {
                gameState.burnPile = syncedState.burnPile.map(rank => CARDS.find(c => c.rank === rank));
            }
            
            // Update game phase
            if (syncedState.phase) {
                gameState.phase = syncedState.phase;
            }
            
            // Update current player
            if (syncedState.currentPlayerIndex !== undefined) {
                gameState.currentPlayerIndex = syncedState.currentPlayerIndex;
            }
            
            // Update other state
            gameState.hasAsked = syncedState.hasAsked || false;
            gameState.waitingForBurn = syncedState.waitingForBurn !== undefined ? syncedState.waitingForBurn : null;
            
            // Update playerNeedingAction based on waitingForBurn
            if (gameState.waitingForBurn !== null) {
                gameState.playerNeedingAction = gameState.waitingForBurn;
            } else {
                gameState.playerNeedingAction = null;
            }
            
            // Check if all captains are placed and reveal if needed
            if (gameState.phase === 'captainSelection') {
                const allCaptainsPlaced = gameState.players.every(p => 
                    p.captain && Object.values(p.lineup).some(card => card === p.captain)
                );
                if (allCaptainsPlaced) {
                    revealCaptains();
                }
            }
            
            updateDisplay();
            updateBurnPile();
        }
        
        function syncToFirebase(updates) {
            if (!database || !onlineGame.roomCode || !onlineGame.enabled) return;
            
            const gameRef = database.ref(`rooms/${onlineGame.roomCode}/gameState`);
            gameRef.update(updates);
        }
        
        function syncCaptainToFirebase(playerIndex, captain, position) {
            if (!database || !onlineGame.roomCode || !onlineGame.enabled) return;
            
            const updates = {};
            updates[`captains/${playerIndex}`] = {
                rank: captain.rank,
                position: position
            };
            
            // Remove from hand
            database.ref(`rooms/${onlineGame.roomCode}/gameState/hands/${playerIndex}`).once('value').then((snapshot) => {
                const hand = snapshot.val() || [];
                const newHand = hand.filter(r => r !== captain.rank);
                updates[`hands/${playerIndex}`] = newHand;
                
                syncToFirebase(updates);
            });
        }

        // Card database
        const CARDS = [
            { name: "LeBron James", positions: ["SF"], primary: "CLE", era: "6, 7", ovr: 100, rank: 1, goat: true, special: "anywhere" },
            { name: "Michael Jordan", positions: ["SG"], primary: "CHI", era: "4, 5", ovr: 99, rank: 2, goat: true },
            { name: "Kareem Abdul-Jabbar", positions: ["C"], primary: "LAL", era: "3, 4", ovr: 98, rank: 3 },
            { name: "Tim Duncan", positions: ["PF"], primary: "SAS", era: "5, 6", ovr: 97, rank: 4 },
            { name: "Bill Russell", positions: ["C"], primary: "BOS", era: "2", ovr: 95, rank: 5 },
            { name: "Kobe Bryant", positions: ["SG"], primary: "LAL", era: "5, 6", ovr: 95, rank: 6 },
            { name: "Wilt Chamberlain", positions: ["C"], primary: "GSW", era: "2, 3", ovr: 94, rank: 7 },
            { name: "Magic Johnson", positions: ["PG"], primary: "LAL", era: "4", ovr: 94, rank: 8 },
            { name: "Shaquille O'Neal", positions: ["C"], primary: "LAL", era: "5, 6", ovr: 94, rank: 9 },
            { name: "Larry Bird", positions: ["SF"], primary: "BOS", era: "4", ovr: 93, rank: 10 },
            { name: "Karl Malone", positions: ["PF"], primary: "UTA", era: "4, 5", ovr: 93, rank: 11 },
            { name: "Hakeem Olajuwon", positions: ["C"], primary: "HOU", era: "4, 5", ovr: 92, rank: 12 },
            { name: "Kevin Durant", positions: ["SF"], primary: "OKC", era: "6, 7", ovr: 92, rank: 13 },
            { name: "Stephen Curry", positions: ["PG"], primary: "GSW", era: "7", ovr: 92, rank: 14 },
            { name: "Kevin Garnett", positions: ["PF"], primary: "MIN", era: "5, 6", ovr: 91, rank: 15 },
            { name: "David Robinson", positions: ["C"], primary: "SAS", era: "5", ovr: 91, rank: 16 },
            { name: "Dirk Nowitzki", positions: ["PF"], primary: "DAL", era: "5, 6, 7", ovr: 91, rank: 17 },
            { name: "Chris Paul", positions: ["PG"], primary: "LAC", era: "6, 7", ovr: 90, rank: 18 },
            { name: "John Havlicek", positions: ["SF"], primary: "BOS", era: "2, 3", ovr: 90, rank: 19 },
            { name: "Nikola Jokiƒá", positions: ["C"], primary: "DEN", era: "7", ovr: 90, rank: 20 },
            { name: "Jerry West", positions: ["PG"], primary: "LAL", era: "2, 3", ovr: 90, rank: 21 },
            { name: "John Stockton", positions: ["PG"], primary: "UTA", era: "4, 5", ovr: 90, rank: 22 },
            { name: "Giannis Antetokounmpo", positions: ["PF"], primary: "MIL", era: "7", ovr: 89, rank: 23 },
            { name: "Charles Barkley", positions: ["PF"], primary: "PHI", era: "4, 5", ovr: 89, rank: 24 },
            { name: "Oscar Robertson", positions: ["PG"], primary: "SAC", era: "2, 3", ovr: 89, rank: 25 },
            { name: "James Harden", positions: ["SG"], primary: "HOU", era: "7", ovr: 88, rank: 26 },
            { name: "Bob Pettit", positions: ["PF"], primary: "ATL", era: "2", ovr: 88, rank: 27 },
            { name: "Dwyane Wade", positions: ["SG"], primary: "MIA", era: "6, 7", ovr: 88, rank: 28 },
            { name: "Bob Cousy", positions: ["PG"], primary: "BOS", era: "1, 2", ovr: 88, rank: 29 },
            { name: "Moses Malone", positions: ["C"], primary: "HOU", era: "3, 4", ovr: 88, rank: 30 },
            { name: "Scottie Pippen", positions: ["SF"], primary: "CHI", era: "4, 5", ovr: 88, rank: 31 },
            { name: "Kawhi Leonard", positions: ["SF"], primary: "SAS", era: "7", ovr: 88, rank: 32 },
            { name: "Dolph Schayes", positions: ["PF"], primary: "PHI", era: "1, 2", ovr: 87, rank: 33 },
            { name: "Gary Payton", positions: ["PG"], primary: "OKC", era: "5", ovr: 86, rank: 34 },
            { name: "Julius Erving", positions: ["SF"], primary: "PHI", era: "4", ovr: 86, rank: 35 },
            { name: "Jason Kidd", positions: ["PG"], primary: "BKN", era: "5, 6", ovr: 86, rank: 36 },
            { name: "Dwight Howard", positions: ["C"], primary: "ORL", era: "6, 7", ovr: 85, rank: 37 },
            { name: "Russell Westbrook", positions: ["PG"], primary: "OKC", era: "6, 7", ovr: 85, rank: 38 },
            { name: "Clyde Drexler", positions: ["SG"], primary: "POR", era: "4, 5", ovr: 85, rank: 39 },
            { name: "Steve Nash", positions: ["PG"], primary: "PHO", era: "5, 6", ovr: 85, rank: 40 },
            { name: "Anthony Davis", positions: ["PF"], primary: "NOP", era: "7", ovr: 84, rank: 41 },
            { name: "George Mikan", positions: ["C"], primary: "LAL", era: "1", ovr: 84, rank: 42 },
            { name: "Elgin Baylor", positions: ["SF"], primary: "LAL", era: "2, 3", ovr: 84, rank: 43 },
            { name: "Sam Jones", positions: ["SG"], primary: "BOS", era: "2", ovr: 84, rank: 44 },
            { name: "Walt Frazier", positions: ["PG"], primary: "NYK", era: "3", ovr: 84, rank: 45 },
            { name: "Allen Iverson", positions: ["SG"], primary: "PHI", era: "5, 6", ovr: 84, rank: 46 },
            { name: "Patrick Ewing", positions: ["C"], primary: "NYK", era: "4, 5", ovr: 84, rank: 47 },
            { name: "Paul Pierce", positions: ["SF"], primary: "BOS", era: "5, 6", ovr: 84, rank: 48 },
            { name: "Isiah Thomas", positions: ["PG"], primary: "DET", era: "4", ovr: 83, rank: 49 },
            { name: "Ben Wallace", positions: ["C"], primary: "DET", era: "5, 6", ovr: 83, rank: 50 },
            { name: "Jimmy Butler", positions: ["SF"], primary: "MIA", era: "7", ovr: 83, rank: 51 },
            { name: "Bill Sharman", positions: ["SG"], primary: "BOS", era: "1, 2", ovr: 83, rank: 52 },
            { name: "Elvin Hayes", positions: ["PF"], primary: "WAS", era: "3, 4", ovr: 83, rank: 53 },
            { name: "Joel Embiid", positions: ["C"], primary: "PHI", era: "7", ovr: 83, rank: 54 },
            { name: "Damian Lillard", positions: ["PG"], primary: "POR", era: "7", ovr: 83, rank: 55 },
            { name: "Willis Reed", positions: ["C"], primary: "NYK", era: "3", ovr: 83, rank: 56 },
            { name: "Rudy Gobert", positions: ["C"], primary: "UTA", era: "7", ovr: 82, rank: 57 },
            { name: "Paul George", positions: ["SF"], primary: "IND", era: "7", ovr: 82, rank: 58 },
            { name: "Dikembe Mutombo", positions: ["C"], primary: "ATL", era: "5, 6", ovr: 82, rank: 59 },
            { name: "Ray Allen", positions: ["SG"], primary: "MIL", era: "5, 6", ovr: 82, rank: 60 },
            { name: "Pau Gasol", positions: ["C"], primary: "LAL", era: "6, 7", ovr: 82, rank: 61 },
            { name: "Tracy McGrady", positions: ["SG"], primary: "ORL", era: "5, 6", ovr: 82, rank: 62 },
            { name: "Tom Heinsohn", positions: ["PF"], primary: "BOS", era: "2", ovr: 82, rank: 63 },
            { name: "Dominique Wilkins", positions: ["SF"], primary: "ATL", era: "4, 5", ovr: 82, rank: 64 },
            { name: "Hal Greer", positions: ["SG"], primary: "PHI", era: "2, 3", ovr: 82, rank: 65 },
            { name: "Sidney Moncrief", positions: ["SG"], primary: "MIL", era: "4", ovr: 82, rank: 66 },
            { name: "Manu Gin√≥bili", positions: ["SG"], primary: "SAS", era: "6, 7", ovr: 82, rank: 67 },
            { name: "Draymond Green", positions: ["PF"], primary: "GSW", era: "7", ovr: 82, rank: 68 },
            { name: "Rick Barry", positions: ["SF"], primary: "GSW", era: "3", ovr: 82, rank: 69 },
            { name: "Kevin McHale", positions: ["PF"], primary: "BOS", era: "4", ovr: 81, rank: 70 },
            { name: "Paul Arizin", positions: ["SF"], primary: "GSW", era: "1, 2", ovr: 81, rank: 71 },
            { name: "Robert Parish", positions: ["C"], primary: "BOS", era: "4, 5", ovr: 81, rank: 72 },
            { name: "Reggie Miller", positions: ["SG"], primary: "IND", era: "4, 5", ovr: 81, rank: 73 },
            { name: "Chauncey Billups", positions: ["PG"], primary: "DET", era: "5, 6", ovr: 81, rank: 74 },
            { name: "Kyrie Irving", positions: ["PG"], primary: "CLE", era: "7", ovr: 81, rank: 75 },
            { name: "Dave Cowens", positions: ["C"], primary: "BOS", era: "3", ovr: 81, rank: 76 },
            { name: "Vern Mikkelsen", positions: ["PF"], primary: "LAL", era: "1", ovr: 81, rank: 77 },
            { name: "Tony Parker", positions: ["PG"], primary: "SAS", era: "6, 7", ovr: 81, rank: 78 },
            { name: "Luka Donƒçiƒá", positions: ["PG"], primary: "DAL", era: "7", ovr: 81, rank: 79 },
            { name: "George Gervin", positions: ["SG"], primary: "SAS", era: "4", ovr: 81, rank: 80 },
            { name: "Jayson Tatum", positions: ["SF"], primary: "BOS", era: "7", ovr: 81, rank: 81 },
            { name: "Neil Johnston", positions: ["C"], primary: "GSW", era: "1", ovr: 81, rank: 82 },
            { name: "Shai Gilgeous-Alexander", positions: ["PG"], primary: "OKC", era: "7", ovr: 80, rank: 83 },
            { name: "Carmelo Anthony", positions: ["SF"], primary: "DEN", era: "6, 7", ovr: 80, rank: 84 },
            { name: "Dennis Rodman", positions: ["PF"], primary: "DET", era: "4, 5", ovr: 80, rank: 85 },
            { name: "Wes Unseld", positions: ["C"], primary: "WAS", era: "3", ovr: 80, rank: 86 },
            { name: "James Worthy", positions: ["SF"], primary: "LAL", era: "4", ovr: 80, rank: 87 },
            { name: "Ed Macauley", positions: ["C"], primary: "BOS", era: "1", ovr: 80, rank: 88 },
            { name: "Dennis Johnson", positions: ["PG"], primary: "BOS", era: "4", ovr: 80, rank: 89 },
            { name: "Alonzo Mourning", positions: ["C"], primary: "MIA", era: "5, 6", ovr: 80, rank: 90 },
            { name: "Jerry Lucas", positions: ["PF"], primary: "SAC", era: "3", ovr: 80, rank: 91 },
            { name: "Slater Martin", positions: ["PG"], primary: "LAL", era: "1", ovr: 80, rank: 92 },
            { name: "Chris Bosh", positions: ["C"], primary: "TOR", era: "6", ovr: 80, rank: 93 },
            { name: "Al Horford", positions: ["C"], primary: "ATL", era: "6, 7", ovr: 80, rank: 94 },
            { name: "Grant Hill", positions: ["SF"], primary: "DET", era: "5, 6", ovr: 79, rank: 95 },
            { name: "Vince Carter", positions: ["SG"], primary: "TOR", era: "5, 6, 7", ovr: 79, rank: 96 },
            { name: "Joe Dumars", positions: ["SG"], primary: "DET", era: "4, 5", ovr: 79, rank: 97 },
            { name: "Blake Griffin", positions: ["PF"], primary: "LAC", era: "7", ovr: 79, rank: 98 },
            { name: "Yao Ming", positions: ["C"], primary: "HOU", era: "6", ovr: 79, rank: 99 },
            { name: "Kevin Johnson", positions: ["PG"], primary: "PHO", era: "4, 5", ovr: 79, rank: 100 },
            { name: "Bailey Howell", positions: ["PF"], primary: "DET", era: "2", ovr: 79, rank: 101 },
            { name: "Chris Webber", positions: ["PF"], primary: "SAC", era: "5, 6", ovr: 79, rank: 102 },
            { name: "LaMarcus Aldridge", positions: ["PF"], primary: "POR", era: "6, 7", ovr: 79, rank: 103 },
            { name: "Bob McAdoo", positions: ["C"], primary: "LAC", era: "3, 4", ovr: 79, rank: 104 },
            { name: "Bill Walton", positions: ["C"], primary: "POR", era: "3, 4", ovr: 79, rank: 105 },
            { name: "Bobby Jones", positions: ["PF"], primary: "PHI", era: "4", ovr: 79, rank: 106 },
            { name: "Adrian Dantley", positions: ["SF"], primary: "UTA", era: "4", ovr: 79, rank: 107 },
            { name: "Chet Walker", positions: ["SF"], primary: "CHI", era: "2, 3", ovr: 79, rank: 108 },
            { name: "Bob Lanier", positions: ["C"], primary: "DET", era: "3, 4", ovr: 79, rank: 109 },
            { name: "Tim Hardaway", positions: ["PG"], primary: "MIA", era: "5", ovr: 79, rank: 110 },
            { name: "Robert Horry", positions: ["PF"], primary: "LAL", era: "5, 6", ovr: 79, rank: 111 },
            { name: "Marc Gasol", positions: ["C"], primary: "MEM", era: "6, 7", ovr: 79, rank: 112 },
            { name: "Alex English", positions: ["SF"], primary: "DEN", era: "4", ovr: 79, rank: 113 },
            { name: "Maurice Cheeks", positions: ["PG"], primary: "PHI", era: "4", ovr: 78, rank: 114 },
            { name: "Horace Grant", positions: ["PF"], primary: "CHI", era: "4, 5", ovr: 78, rank: 115 },
            { name: "Shawn Marion", positions: ["SF"], primary: "PHO", era: "6", ovr: 78, rank: 116 },
            { name: "Kyle Lowry", positions: ["PG"], primary: "TOR", era: "6, 7", ovr: 78, rank: 117 },
            { name: "Andre Iguodala", positions: ["SF"], primary: "PHI", era: "6, 7", ovr: 78, rank: 118 },
            { name: "Amar'e Stoudemire", positions: ["C"], primary: "PHO", era: "6", ovr: 78, rank: 119 },
            { name: "Chris Mullin", positions: ["SF"], primary: "GSW", era: "4, 5", ovr: 78, rank: 120 },
            { name: "Karl-Anthony Towns", positions: ["C"], primary: "MIN", era: "7", ovr: 78, rank: 121 },
            { name: "Paul Westphal", positions: ["SG"], primary: "PHO", era: "3, 4", ovr: 78, rank: 122 },
            { name: "Cliff Hagan", positions: ["SF"], primary: "ATL", era: "2", ovr: 78, rank: 123 },
            { name: "Michael Cooper", positions: ["SG"], primary: "LAL", era: "4", ovr: 78, rank: 124 },
            { name: "Larry Foust", positions: ["C"], primary: "DET", era: "1, 2", ovr: 78, rank: 125 },
            { name: "Kevin Love", positions: ["PF"], primary: "CLE", era: "6, 7", ovr: 78, rank: 126 },
            { name: "Mitch Richmond", positions: ["SG"], primary: "SAC", era: "5", ovr: 78, rank: 127 },
            { name: "Jim Pollard", positions: ["SF"], primary: "LAL", era: "1", ovr: 78, rank: 128 },
            { name: "Harry Gallatin", positions: ["PF"], primary: "NYK", era: "1", ovr: 78, rank: 129 },
            { name: "Dave DeBusschere", positions: ["PF"], primary: "DET", era: "2, 3", ovr: 78, rank: 130 },
            { name: "Marques Johnson", positions: ["SF"], primary: "MIL", era: "4", ovr: 78, rank: 131 },
            { name: "Mark Price", positions: ["PG"], primary: "CLE", era: "4, 5", ovr: 78, rank: 132 },
            { name: "Bobby Wanzer", positions: ["SG"], primary: "SAC", era: "1", ovr: 78, rank: 133 },
            { name: "Klay Thompson", positions: ["SG"], primary: "GSW", era: "7", ovr: 78, rank: 134 },
            { name: "Clyde Lovellette", positions: ["C"], primary: "LAL", era: "2", ovr: 78, rank: 135 },
            { name: "Jo Jo White", positions: ["PG"], primary: "BOS", era: "3", ovr: 78, rank: 136 },
            { name: "Bob Dandridge", positions: ["SF"], primary: "MIL", era: "3", ovr: 77, rank: 137 },
            { name: "Jack Sikma", positions: ["C"], primary: "OKC", era: "4", ovr: 77, rank: 138 },
            { name: "Frank Ramsey", positions: ["SG"], primary: "BOS", era: "2", ovr: 77, rank: 139 },
            { name: "Don Nelson", positions: ["SF"], primary: "BOS", era: "2, 3", ovr: 77, rank: 140 },
            { name: "Tom Sanders", positions: ["SF"], primary: "BOS", era: "2, 3", ovr: 77, rank: 141 },
            { name: "Rajon Rondo", positions: ["PG"], primary: "BOS", era: "6, 7", ovr: 77, rank: 142 },
            { name: "Donovan Mitchell", positions: ["SG"], primary: "UTA", era: "7", ovr: 77, rank: 143 },
            { name: "Tiny Archibald", positions: ["PG"], primary: "SAC", era: "3, 4", ovr: 77, rank: 144 },
            { name: "Bob Davies", positions: ["PG"], primary: "SAC", era: "1", ovr: 77, rank: 145 },
            { name: "Rasheed Wallace", positions: ["PF"], primary: "POR", era: "5, 6", ovr: 77, rank: 146 },
            { name: "George Yardley", positions: ["SF"], primary: "DET", era: "2", ovr: 77, rank: 147 },
            { name: "Eddie Jones", positions: ["SG"], primary: "MIA", era: "5, 6", ovr: 77, rank: 148 },
            { name: "Anfernee Hardaway", positions: ["SG"], primary: "ORL", era: "5, 6", ovr: 77, rank: 149 },
            { name: "Billy Cunningham", positions: ["SF"], primary: "PHI", era: "3", ovr: 77, rank: 150 },
            { name: "Larry Nance", positions: ["PF"], primary: "CLE", era: "4", ovr: 77, rank: 151 },
            { name: "Shawn Kemp", positions: ["PF"], primary: "OKC", era: "5", ovr: 77, rank: 152 },
            { name: "Gus Williams", positions: ["PG"], primary: "OKC", era: "4", ovr: 77, rank: 153 },
            { name: "Lenny Wilkens", positions: ["PG"], primary: "ATL", era: "2, 3", ovr: 77, rank: 154 },
            { name: "Paul Silas", positions: ["PF"], primary: "BOS", era: "3", ovr: 77, rank: 155 },
            { name: "DeMar DeRozan", positions: ["SG"], primary: "TOR", era: "7", ovr: 77, rank: 156 },
            { name: "Walt Bellamy", positions: ["C"], primary: "WAS", era: "2, 3", ovr: 77, rank: 157 },
            { name: "Bernard King", positions: ["SF"], primary: "NYK", era: "4", ovr: 77, rank: 158 },
            { name: "Richie Guerin", positions: ["SG"], primary: "NYK", era: "2", ovr: 77, rank: 159 },
            { name: "Alvin Robertson", positions: ["SG"], primary: "SAS", era: "4", ovr: 77, rank: 160 },
            { name: "Bill Laimbeer", positions: ["C"], primary: "DET", era: "4", ovr: 77, rank: 161 },
            { name: "Jrue Holiday", positions: ["PG"], primary: "NOP", era: "7", ovr: 77, rank: 162 },
            { name: "Artis Gilmore", positions: ["C"], primary: "CHI", era: "4", ovr: 77, rank: 163 },
            { name: "Walter Davis", positions: ["SG"], primary: "PHO", era: "4", ovr: 76, rank: 164 },
            { name: "Nate Thurmond", positions: ["C"], primary: "GSW", era: "3", ovr: 76, rank: 165 },
            { name: "Jack Twyman", positions: ["SF"], primary: "SAC", era: "2", ovr: 76, rank: 166 },
            { name: "Larry Costello", positions: ["PG"], primary: "PHI", era: "2", ovr: 76, rank: 167 },
            { name: "Dave Bing", positions: ["PG"], primary: "DET", era: "3", ovr: 76, rank: 168 },
            { name: "Ron Harper", positions: ["SG"], primary: "CHI", era: "4, 5", ovr: 76, rank: 169 },
            { name: "K.C. Jones", positions: ["PG"], primary: "BOS", era: "2", ovr: 76, rank: 170 },
            { name: "Terry Porter", positions: ["PG"], primary: "POR", era: "4, 5", ovr: 76, rank: 171 },
            { name: "DeAndre Jordan", positions: ["C"], primary: "LAC", era: "6, 7", ovr: 76, rank: 172 },
            { name: "Lou Hudson", positions: ["SF"], primary: "ATL", era: "3", ovr: 76, rank: 173 },
            { name: "Jeff Hornacek", positions: ["SG"], primary: "UTA", era: "4, 5", ovr: 76, rank: 174 },
            { name: "Gail Goodrich", positions: ["SG"], primary: "LAL", era: "3", ovr: 76, rank: 175 },
            { name: "Sam Cassell", positions: ["PG"], primary: "MIL", era: "5, 6", ovr: 76, rank: 176 },
            { name: "Pascal Siakam", positions: ["PF"], primary: "TOR", era: "7", ovr: 76, rank: 177 },
            { name: "Earl Monroe", positions: ["SG"], primary: "NYK", era: "3", ovr: 76, rank: 178 },
            { name: "Carl Braun", positions: ["SG"], primary: "NYK", era: "1, 2", ovr: 76, rank: 179 },
            { name: "Tyrese Haliburton", positions: ["PG"], primary: "IND", era: "7", ovr: 76, rank: 180 },
            { name: "Andrei Kirilenko", positions: ["SF"], primary: "UTA", era: "6", ovr: 76, rank: 181 },
            { name: "Domantas Sabonis", positions: ["C"], primary: "SAC", era: "7", ovr: 76, rank: 182 },
            { name: "Deron Williams", positions: ["PG"], primary: "UTA", era: "6", ovr: 76, rank: 183 },
            { name: "Arnie Risen", positions: ["C"], primary: "SAC", era: "1", ovr: 76, rank: 184 },
            { name: "Peja Stojakoviƒá", positions: ["SF"], primary: "SAC", era: "5, 6", ovr: 76, rank: 185 },
            { name: "Jermaine O'Neal", positions: ["PF"], primary: "IND", era: "5, 6", ovr: 76, rank: 186 },
            { name: "Brad Daugherty", positions: ["C"], primary: "CLE", era: "4", ovr: 76, rank: 187 },
            { name: "Jamaal Wilkes", positions: ["SF"], primary: "LAL", era: "3, 4", ovr: 76, rank: 188 },
            { name: "Detlef Schrempf", positions: ["SF"], primary: "OKC", era: "4, 5", ovr: 76, rank: 189 },
            { name: "Gilbert Arenas", positions: ["PG"], primary: "WAS", era: "6", ovr: 76, rank: 190 },
            { name: "Paul Millsap", positions: ["PF"], primary: "UTA", era: "6, 7", ovr: 76, rank: 191 },
            { name: "Joe Johnson", positions: ["SG"], primary: "ATL", era: "6, 7", ovr: 76, rank: 192 },
            { name: "David West", positions: ["PF"], primary: "NOP", era: "6, 7", ovr: 76, rank: 193 },
            { name: "Metta World Peace", positions: ["SF"], primary: "IND", era: "6", ovr: 76, rank: 194 },
            { name: "Toni Kukoƒç", positions: ["SF"], primary: "CHI", era: "5", ovr: 76, rank: 195 },
            { name: "Andy Phillip", positions: ["PG"], primary: "DET", era: "1", ovr: 76, rank: 196 },
            { name: "Bam Adebayo", positions: ["C"], primary: "MIA", era: "7", ovr: 75, rank: 197 },
            { name: "Mookie Blaylock", positions: ["PG"], primary: "ATL", era: "5", ovr: 75, rank: 198 },
            { name: "Dan Majerle", positions: ["SF"], primary: "PHO", era: "5", ovr: 75, rank: 199 },
            { name: "Gus Johnson", positions: ["PF"], primary: "WAS", era: "3", ovr: 75, rank: 200 },
            { name: "Pete Maravich", positions: ["SG"], primary: "ATL", era: "3", ovr: 75, rank: 201 },
            { name: "Elton Brand", positions: ["PF"], primary: "LAC", era: "6", ovr: 75, rank: 202 },
            { name: "Dick McGuire", positions: ["PG"], primary: "NYK", era: "1", ovr: 75, rank: 203 },
            { name: "David Thompson", positions: ["SG"], primary: "DEN", era: "4", ovr: 75, rank: 204 },
            { name: "Glen Rice", positions: ["SF"], primary: "MIA", era: "5", ovr: 75, rank: 205 },
            { name: "Mike Conley", positions: ["PG"], primary: "MEM", era: "6, 7", ovr: 75, rank: 206 },
            { name: "Derrick Rose", positions: ["PG"], primary: "CHI", era: "6, 7", ovr: 75, rank: 207 },
            { name: "Mark Aguirre", positions: ["SF"], primary: "DAL", era: "4", ovr: 75, rank: 208 },
            { name: "John Wall", positions: ["PG"], primary: "WAS", era: "7", ovr: 75, rank: 209 },
            { name: "Spencer Haywood", positions: ["PF"], primary: "OKC", era: "3", ovr: 75, rank: 210 },
            { name: "Tyson Chandler", positions: ["C"], primary: "NYK", era: "6, 7", ovr: 75, rank: 211 },
            { name: "Kemba Walker", positions: ["PG"], primary: "CHA", era: "7", ovr: 75, rank: 212 },
            { name: "Joe Fulks", positions: ["PF"], primary: "GSW", era: "1", ovr: 75, rank: 213 },
            { name: "Marcus Camby", positions: ["C"], primary: "DEN", era: "5, 6", ovr: 75, rank: 214 },
            { name: "Jalen Brunson", positions: ["PG"], primary: "NYK", era: "7", ovr: 75, rank: 215 },
            { name: "Max Zaslofsky", positions: ["SG"], primary: "CHS", era: "1", ovr: 75, rank: 216 },
            { name: "Jaylen Brown", positions: ["SF"], primary: "BOS", era: "7", ovr: 75, rank: 217 },
            { name: "Buck Williams", positions: ["PF"], primary: "BKN", era: "4, 5", ovr: 75, rank: 218 },
            { name: "Fat Lever", positions: ["PG"], primary: "DEN", era: "4", ovr: 75, rank: 219 },
            { name: "Rashard Lewis", positions: ["SF"], primary: "OKC", era: "5, 6", ovr: 75, rank: 220 },
            { name: "Tom Gola", positions: ["SG"], primary: "GSW", era: "2", ovr: 75, rank: 221 },
            { name: "Baron Davis", positions: ["PG"], primary: "GSW", era: "6", ovr: 75, rank: 222 },
            { name: "Danny Green", positions: ["SG"], primary: "SAS", era: "7", ovr: 75, rank: 223 },
            { name: "DeMarcus Cousins", positions: ["C"], primary: "SAC", era: "7", ovr: 75, rank: 224 },
            { name: "Ben Simmons", positions: ["PG"], primary: "PHI", era: "7", ovr: 75, rank: 225 },
            { name: "Devin Booker", positions: ["SG"], primary: "PHO", era: "7", ovr: 75, rank: 226 },
            { name: "Vlade Divac", positions: ["C"], primary: "LAL", era: "5", ovr: 75, rank: 227 },
            { name: "Lamar Odom", positions: ["PF"], primary: "LAL", era: "6", ovr: 75, rank: 228 },
            { name: "Brook Lopez", positions: ["C"], primary: "BKN", era: "6, 7", ovr: 75, rank: 229 },
            { name: "Terry Cummings", positions: ["PF"], primary: "MIL", era: "4, 5", ovr: 75, rank: 230 },
            { name: "Rudy LaRusso", positions: ["PF"], primary: "LAL", era: "2", ovr: 75, rank: 231 },
            { name: "Trae Young", positions: ["PG"], primary: "ATL", era: "7", ovr: 75, rank: 232 },
            { name: "Derek Fisher", positions: ["PG"], primary: "LAL", era: "5, 6", ovr: 75, rank: 233 },
            { name: "A.C. Green", positions: ["PF"], primary: "LAL", era: "4, 5", ovr: 75, rank: 234 },
            { name: "Bob Love", positions: ["PF"], primary: "CHI", era: "3", ovr: 75, rank: 235 },
            { name: "Shane Battier", positions: ["SF"], primary: "MEM", era: "6", ovr: 75, rank: 236 },
            { name: "Brent Barry", positions: ["SG"], primary: "OKC", era: "5, 6", ovr: 75, rank: 237 },
            { name: "Larry Siegfried", positions: ["PG"], primary: "BOS", era: "3", ovr: 75, rank: 238 },
            { name: "Terrell Brandon", positions: ["PG"], primary: "CLE", era: "5", ovr: 75, rank: 239 },
            { name: "Jason Terry", positions: ["SG"], primary: "DAL", era: "6, 7", ovr: 75, rank: 240 },
            { name: "Michael Finley", positions: ["SF"], primary: "DAL", era: "5, 6", ovr: 75, rank: 241 },
            { name: "Mark Jackson", positions: ["PG"], primary: "NYK", era: "4, 5", ovr: 75, rank: 242 },
            { name: "Norm Van Lier", positions: ["PG"], primary: "CHI", era: "3", ovr: 75, rank: 243 },
            { name: "Doc Rivers", positions: ["PG"], primary: "ATL", era: "4", ovr: 75, rank: 244 },
            { name: "Maurice Lucas", positions: ["PF"], primary: "POR", era: "4", ovr: 75, rank: 245 },
            { name: "Stephon Marbury", positions: ["PG"], primary: "NYK", era: "5, 6", ovr: 75, rank: 246 }
        ];

        let gameState = {
            phase: 'setup', // setup, captainSelection, playing, final
            players: [],
            currentPlayerIndex: 0,
            deck: [],
            burnPile: [],
            selectedCard: null,
            selectedCardPlayer: undefined,
            targetPlayer: null,
            positionAsked: null,
            waitingForBurn: null,
            hasAsked: false,
            viewMode: 'separate', // Always 'separate' for same device
            currentView: null, // Which player's screen is showing (for separate mode)
            newlyAcquiredCard: null, // Track the card just received to highlight it
            playerNeedingAction: null, // Track which player needs to take action (for highlighting)
            menuState: {
                mode: null, // 'local' or 'online'
                humanPlayers: 2,
                aiPlayers: 0
            }
        };

        const POSITIONS = ['PG', 'SG', 'SF', 'PF', 'C'];
        
        // Menu Navigation Functions
        function selectMode(mode) {
            gameState.menuState.mode = mode;
            document.getElementById('modeSelection').style.display = 'none';
            
            if (mode === 'online') {
                document.getElementById('onlineRoom').style.display = 'block';
            } else {
                document.getElementById('playerSelection').style.display = 'block';
            }
        }
        
        function backToModeSelection() {
            document.getElementById('playerSelection').style.display = 'none';
            document.getElementById('onlineRoom').style.display = 'none';
            document.getElementById('modeSelection').style.display = 'block';
        }
        
        function backToPlayerSelection() {
            document.getElementById('onlineRoom').style.display = 'none';
            document.getElementById('playerSelection').style.display = 'block';
        }
        
        function setHumanPlayers(count) {
            gameState.menuState.humanPlayers = count;
            updatePlayerButtons();
        }
        
        function setAIPlayers(count) {
            gameState.menuState.aiPlayers = count;
            updatePlayerButtons();
        }
        
        function updatePlayerButtons() {
            const humanCount = gameState.menuState.humanPlayers;
            const aiCount = gameState.menuState.aiPlayers;
            const total = humanCount + aiCount;
            
            // Update human player buttons
            const humanButtons = document.querySelectorAll('#humanPlayerButtons .player-count-btn');
            humanButtons.forEach((btn, index) => {
                const value = index + 1;
                btn.classList.toggle('selected', value === humanCount);
                btn.disabled = (value + aiCount > 6);
            });
            
            // Update AI player buttons
            const aiButtons = document.querySelectorAll('#aiPlayerButtons .player-count-btn');
            aiButtons.forEach((btn, index) => {
                const value = index;
                btn.classList.toggle('selected', value === aiCount);
                btn.disabled = (humanCount + value > 6);
            });
            
            // Enable/disable confirm button
            document.getElementById('confirmPlayersBtn').disabled = (total < 2 || total > 6);
        }
        
        function confirmPlayerSelection() {
            const total = gameState.menuState.humanPlayers + gameState.menuState.aiPlayers;
            if (total >= 2 && total <= 6) {
                startGame();
            }
        }

        function showLineupReview() {
            const modal = document.getElementById('modalBody');
            
            let html = '<div style="max-height: 500px; overflow-y: auto;">';
            
            gameState.players.forEach(player => {
                const teamOVR = calculateTeamOVR(player);
                
                // Calculate bonuses
                const lockedCards = [];
                POSITIONS.forEach(pos => {
                    if (player.lineup[pos]) {
                        lockedCards.push(player.lineup[pos]);
                    }
                });
                
                let teamBonus = 0;
                let eraBonus = 0;
                
                if (lockedCards.length > 0) {
                    const teamCounts = {};
                    lockedCards.forEach(card => {
                        teamCounts[card.primary] = (teamCounts[card.primary] || 0) + 1;
                    });
                    // STACKING - sum all team bonuses
                    Object.values(teamCounts).forEach(count => {
                        if (count === 2) teamBonus += 2;
                        else if (count === 3) teamBonus += 4;
                        else if (count === 4) teamBonus += 8;
                        else if (count >= 5) teamBonus += 16;
                    });
                    
                    const eraCounts = {};
                    lockedCards.forEach(card => {
                        card.era.split(', ').forEach(era => {
                            eraCounts[era] = (eraCounts[era] || 0) + 1;
                        });
                    });
                    // STACKING - sum all era bonuses
                    Object.values(eraCounts).forEach(count => {
                        if (count === 3) eraBonus += 2;
                        else if (count === 4) eraBonus += 4;
                        else if (count >= 5) eraBonus += 8;
                    });
                }
                
                html += `
                    <div style="margin-bottom: 30px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; border: 2px solid rgba(255,215,0,0.3);">
                        <h3 style="color: #ffd700; margin-bottom: 10px;">${player.name}</h3>
                        <div style="font-size: 1.2em; margin-bottom: 10px;">
                            <strong>Team OVR:</strong> ${teamOVR}
                            ${teamBonus > 0 ? `<span style="color: #ffd700; margin-left: 10px;">üèÜ Team Bonus: +${teamBonus}</span>` : ''}
                            ${eraBonus > 0 ? `<span style="color: #90EE90; margin-left: 10px;">üìÖ Era Bonus: +${eraBonus}</span>` : ''}
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px;">
                `;
                
                POSITIONS.forEach(pos => {
                    const card = player.lineup[pos];
                    if (card) {
                        let cardColor = '';
                        if (card.ovr >= 92) cardColor = 'linear-gradient(135deg, #9B59B6 0%, #8E44AD 100%)'; // Amethyst
                        else if (card.ovr >= 87) cardColor = 'linear-gradient(135deg, #E74C3C 0%, #C0392B 100%)'; // Ruby
                        else if (card.ovr >= 83) cardColor = 'linear-gradient(135deg, #2ECC71 0%, #27AE60 100%)'; // Emerald
                        else if (card.ovr >= 80) cardColor = 'linear-gradient(135deg, #3498DB 0%, #2980B9 100%)'; // Diamond
                        else if (card.ovr >= 78) cardColor = 'linear-gradient(135deg, #DAA520 0%, #B8860B 100%)'; // Gold
                        else if (card.ovr >= 76) cardColor = 'linear-gradient(135deg, #A9A9A9 0%, #808080 100%)'; // Silver
                        else if (card.ovr === 70) cardColor = 'linear-gradient(135deg, #696969 0%, #4B4B4B 100%)'; // Benchwarmer
                        else cardColor = 'linear-gradient(135deg, #CD7F32 0%, #8B4513 100%)'; // Bronze
                        
                        const penalty = !card.positions.includes(pos) ? calculatePositionPenalty(card, pos) : 0;
                        
                        html += `
                            <div style="background: ${cardColor}; padding: 10px; border-radius: 8px; text-align: center; border: 2px solid rgba(255,255,255,0.3);">
                                <div style="font-size: 0.7em; font-weight: bold; color: #ffd700;">${pos} SLOT</div>
                                <div style="font-size: 0.8em; font-weight: bold; margin-top: 5px;">${card.name}</div>
                                <div style="font-size: 1.2em; font-weight: bold; margin: 5px 0;">${card.ovr} OVR</div>
                                <div style="font-size: 0.7em;">${card.positions.join('/')}</div>
                                <div style="font-size: 0.65em; margin-top: 3px;">${card.primary} | Era ${card.era}</div>
                                <div style="font-size: 0.65em; color: rgba(255,255,255,0.7);">Rank #${card.rank}</div>
                                ${penalty > 0 ? `<div style="font-size: 0.75em; color: #ff9999; margin-top: 3px; font-weight: bold;">-${penalty} OVR PENALTY</div>` : ''}
                                ${card === player.captain ? '<div style="font-size: 0.75em; color: #ffd700; margin-top: 3px;">‚≠ê CAPTAIN</div>' : ''}
                            </div>
                        `;
                    } else {
                        html += `
                            <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; text-align: center; border: 2px dashed rgba(255,255,255,0.2);">
                                <div style="font-size: 0.7em; font-weight: bold; color: #ffd700;">${pos} SLOT</div>
                                <div style="font-size: 0.75em; margin-top: 15px; color: #888;">Empty</div>
                            </div>
                        `;
                    }
                });
                
                html += '</div></div>';
            });
            
            html += '</div>';
            modal.innerHTML = html;
            showModal('üë• Lineup Review');
        }

        function showInstructions() {
            const modal = document.getElementById('modalBody');
            modal.innerHTML = `
                <div style="max-height: 500px; overflow-y: auto; text-align: left;">
                    <h2 style="color: #ffd700;">Starting Five - Game Rules</h2>
                    
                    <h3 style="color: #90EE90; margin-top: 20px;">üéØ Objective</h3>
                    <p>Build the best starting lineup of 5 NBA players by strategically drafting cards and maximizing your Team OVR (Overall Rating).</p>
                    
                    <h3 style="color: #90EE90; margin-top: 20px;">üèÄ Setup</h3>
                    <ul>
                        <li>Each player is dealt 8 cards</li>
                        <li>Select a captain from your hand and place it face-down in any position</li>
                        <li>The player with the WORST captain (highest rank number) goes first</li>
                    </ul>
                    
                    <h3 style="color: #90EE90; margin-top: 20px;">üéÆ Turn Flow</h3>
                    <p><strong>1. Ask for a Position</strong></p>
                    <ul>
                        <li>Ask any opponent for a specific position (PG, SG, SF, PF, C)</li>
                        <li>If they have it: They give you their BEST card (highest OVR) with that position ‚Üí They draw a card ‚Üí You burn a card</li>
                        <li>If they don't have it: They draw a card ‚Üí You don't burn (you keep all your cards!)</li>
                    </ul>
                    
                    <p><strong>2. Lock In a Card (Optional)</strong></p>
                    <ul>
                        <li>Place a card from your hand into a position slot</li>
                        <li>You give your BEST card to the player <strong>counterclockwise</strong> (to your right)</li>
                        <li>You draw a card</li>
                        <li>They burn a card</li>
                        <li>The player <strong>clockwise</strong> from you (to your left) takes their turn next</li>
                    </ul>
                    
                    <p><strong>3. End Turn</strong></p>
                    <ul>
                        <li>If you didn't lock in a card, click "End Turn"</li>
                        <li>Next player <strong>clockwise</strong> (to your left) takes their turn</li>
                    </ul>
                    
                    <h3 style="color: #90EE90; margin-top: 20px;">üìä Position Rules</h3>
                    <p>Cards can only be placed in valid positions:</p>
                    <ul>
                        <li><strong>PG</strong> ‚Üí PG or SG</li>
                        <li><strong>SG</strong> ‚Üí PG, SG, or SF</li>
                        <li><strong>SF</strong> ‚Üí SG, SF, or PF</li>
                        <li><strong>PF</strong> ‚Üí SF, PF, or C</li>
                        <li><strong>C</strong> ‚Üí PF or C</li>
                        <li><strong>LeBron James</strong> ‚Üí ANY position (special ability!)</li>
                    </ul>
                    
                    <h3 style="color: #90EE90; margin-top: 20px;">‚ö†Ô∏è Out-of-Position Penalties</h3>
                    <ul>
                        <li>Adjacent positions (SG/SF, SF/PF): <strong>-6 OVR</strong></li>
                        <li>PG‚ÜíSG or C‚ÜíPF: <strong>-4 OVR</strong></li>
                        <li>LeBron out of SF: <strong>-4 OVR</strong> (instead of -6)</li>
                    </ul>
                    
                    <h3 style="color: #90EE90; margin-top: 20px;">üèÜ Bonuses (STACKING!)</h3>
                    <p><strong>GOAT Bonus:</strong> LeBron/Jordan get +4 OVR if you have no other 90+ OVR cards</p>
                    
                    <p><strong>Team Chemistry (bonuses stack!):</strong></p>
                    <ul>
                        <li>2 same team cards: <strong>+2 OVR</strong></li>
                        <li>3 same team cards: <strong>+4 OVR</strong></li>
                        <li>4 same team cards: <strong>+8 OVR</strong></li>
                        <li>5 same team cards: <strong>+16 OVR</strong></li>
                        <li>Example: 2 Lakers + 2 Celtics = +2 + +2 = <strong>+4 OVR total</strong></li>
                    </ul>
                    
                    <p><strong>Era Synergy (bonuses stack!):</strong></p>
                    <ul>
                        <li>3 cards with same era: <strong>+2 OVR</strong></li>
                        <li>4 cards with same era: <strong>+4 OVR</strong></li>
                        <li>5 cards with same era: <strong>+8 OVR</strong></li>
                        <li>Example: 3 Era 4 cards + 3 Era 5 cards = +2 + +2 = <strong>+4 OVR total</strong></li>
                    </ul>
                    
                    <h3 style="color: #90EE90; margin-top: 20px;">üéØ Winning</h3>
                    <p>First player to complete their starting lineup (5 cards) triggers the end of the game. Empty positions are automatically filled with the best available cards from your hand (or benchwarmers if none fit). The player with the HIGHEST Team OVR wins!</p>
                    
                    <p style="margin-top: 20px; padding: 10px; background: rgba(255,215,0,0.2); border-radius: 5px;">
                        <strong>üí° Pro Tip:</strong> Cards in your hand show potential bonuses (üèÜ for team, üìÖ for era) to help you make strategic decisions!
                    </p>
                </div>
            `;
            showModal('üìñ Game Instructions');
        }

        function showCardIndex() {
            const modal = document.getElementById('modalBody');
            
            // Group cards by OVR tier with new rarity names
            const tiers = {
                'Amethyst (92+)': CARDS.filter(c => c.ovr >= 92),
                'Ruby (87-91)': CARDS.filter(c => c.ovr >= 87 && c.ovr < 92),
                'Emerald (83-86)': CARDS.filter(c => c.ovr >= 83 && c.ovr < 87),
                'Diamond (80-82)': CARDS.filter(c => c.ovr >= 80 && c.ovr < 83),
                'Gold (78-79)': CARDS.filter(c => c.ovr >= 78 && c.ovr < 80),
                'Silver (76-77)': CARDS.filter(c => c.ovr >= 76 && c.ovr < 78),
                'Bronze (75)': CARDS.filter(c => c.ovr === 75)
            };
            
            let html = '<div style="max-height: 500px; overflow-y: auto;">';
            
            for (const [tierName, cards] of Object.entries(tiers)) {
                html += `<h3 style="margin-top: 20px; color: #ffd700;">${tierName} (${cards.length} cards)</h3>`;
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; margin-bottom: 20px;">';
                
                cards.forEach(card => {
                    let cardColor = '';
                    if (card.ovr >= 92) cardColor = 'linear-gradient(135deg, #9B59B6 0%, #8E44AD 100%)'; // Amethyst
                    else if (card.ovr >= 87) cardColor = 'linear-gradient(135deg, #E74C3C 0%, #C0392B 100%)'; // Ruby
                    else if (card.ovr >= 83) cardColor = 'linear-gradient(135deg, #2ECC71 0%, #27AE60 100%)'; // Emerald
                    else if (card.ovr >= 80) cardColor = 'linear-gradient(135deg, #3498DB 0%, #2980B9 100%)'; // Diamond
                    else if (card.ovr >= 78) cardColor = 'linear-gradient(135deg, #DAA520 0%, #B8860B 100%)'; // Gold
                    else if (card.ovr >= 76) cardColor = 'linear-gradient(135deg, #A9A9A9 0%, #808080 100%)'; // Silver
                    else cardColor = 'linear-gradient(135deg, #CD7F32 0%, #8B4513 100%)'; // Bronze
                    
                    html += `
                        <div style="background: ${cardColor}; padding: 10px; border-radius: 8px; text-align: center; border: 2px solid rgba(255,255,255,0.3);">
                            <div style="font-size: 0.8em; font-weight: bold;">${card.name}</div>
                            <div style="font-size: 1.2em; font-weight: bold; margin: 5px 0;">${card.ovr} OVR</div>
                            <div style="font-size: 0.7em;">${card.positions.join('/')}</div>
                            <div style="font-size: 0.65em; margin-top: 3px;">${card.primary} | Era ${card.era}</div>
                            <div style="font-size: 0.65em; color: rgba(255,255,255,0.7);">Rank #${card.rank}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            html += '</div>';
            modal.innerHTML = html;
            showModal('Card Index - All 246 Players');
        }

        function startGame() {
            const humanCount = gameState.menuState.humanPlayers;
            const aiCount = gameState.menuState.aiPlayers;
            const totalPlayers = humanCount + aiCount;
            
            // Always use separate mode for same device
            gameState.viewMode = 'separate';
            
            // Check if this is online mode
            if (onlineGame.enabled) {
                gameState.viewMode = 'online'; // Force online view mode
            }
            
            // Initialize players
            gameState.players = [];
            for (let i = 0; i < totalPlayers; i++) {
                const isAI = i >= humanCount;
                gameState.players.push({
                    id: i,
                    name: isAI ? `ü§ñ AI Player ${i - humanCount + 1}` : `Player ${i + 1}`,
                    hand: [],
                    lineup: { PG: null, SG: null, SF: null, PF: null, C: null },
                    captain: null,
                    captainHidden: false,
                    isAI: isAI
                });
            }

            // Create and shuffle deck
            gameState.deck = [...CARDS];
            shuffleDeck();

            // Deal 8 cards to each player
            for (let i = 0; i < 8; i++) {
                for (let player of gameState.players) {
                    player.hand.push(gameState.deck.pop());
                }
            }

            gameState.phase = 'captainSelection';
            
            // Set view based on mode
            if (onlineGame.enabled && onlineGame.gamePlayerId !== undefined) {
                // In online mode, set currentView to this player's game ID
                gameState.currentView = onlineGame.gamePlayerId;
            } else {
                // Start with first human player's view
                gameState.currentView = 0;
            }
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            updateDisplay();
            
            // Auto-select and place captain for AI players
            setTimeout(() => {
                gameState.players.forEach(player => {
                    if (player.isAI && !player.captain) {
                        aiSelectCaptain(player);
                    }
                });
            }, 500);
            
            showMessage("Each player: Select a captain from your hand and click 'Set Captain'");
        }

        function shuffleDeck() {
            for (let i = gameState.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
        }

        function updateDisplay() {
            const container = document.getElementById('playersContainer');
            container.innerHTML = '';

            if ((gameState.viewMode === 'separate' || gameState.viewMode === 'online') && gameState.currentView !== null && gameState.phase !== 'final') {
                // Show only the current player's full view (except at end of game)
                const player = gameState.players[gameState.currentView];
                renderPlayerView(player, true, container);
                
                // Show other players' lineups only (no hands)
                gameState.players.forEach((p, index) => {
                    if (index !== gameState.currentView) {
                        renderPlayerView(p, false, container);
                    }
                });
            } else {
                // Shared mode or final phase - show everything
                gameState.players.forEach((player, index) => {
                    renderPlayerView(player, true, container);
                });
            }

            updateControls();
            updatePhaseText();
        }

        function renderPlayerView(player, showHand, container) {
            const playerDiv = document.createElement('div');
            playerDiv.className = 'player-area';
            
            // Add winner class if this player won
            if (gameState.phase === 'final' && gameState.winnerPlayerId === player.id) {
                playerDiv.className += ' winner';
            }
            // Highlight the player who needs to take action (NOT during final phase)
            else if (gameState.phase !== 'final' && gameState.playerNeedingAction === player.id) {
                playerDiv.className += ' active';
            } else if (gameState.phase !== 'final' && player.id === gameState.currentPlayerIndex && gameState.phase === 'playing' && gameState.playerNeedingAction === null) {
                playerDiv.className += ' active';
            }

            const teamOVR = calculateTeamOVR(player);
            
            // Calculate individual bonuses for display
            const lockedCards = [];
            POSITIONS.forEach(pos => {
                if (player.lineup[pos]) {
                    lockedCards.push(player.lineup[pos]);
                }
            });
            
            let teamBonus = 0;
            let eraBonus = 0;
            let goatBonus = 0;
            
            if (lockedCards.length > 0) {
                // Team chemistry bonus - STACKING
                const teamCounts = {};
                lockedCards.forEach(card => {
                    teamCounts[card.primary] = (teamCounts[card.primary] || 0) + 1;
                });
                // Sum bonuses from all team groups
                Object.values(teamCounts).forEach(count => {
                    if (count === 2) teamBonus += 2;
                    else if (count === 3) teamBonus += 4;
                    else if (count === 4) teamBonus += 8;
                    else if (count >= 5) teamBonus += 16;
                });
                
                // Era bonus - STACKING
                const eraCounts = {};
                lockedCards.forEach(card => {
                    card.era.split(', ').forEach(era => {
                        eraCounts[era] = (eraCounts[era] || 0) + 1;
                    });
                });
                // Sum bonuses from all era groups
                Object.values(eraCounts).forEach(count => {
                    if (count === 3) eraBonus += 2;
                    else if (count === 4) eraBonus += 4;
                    else if (count >= 5) eraBonus += 8;
                });
                
                // GOAT bonus
                lockedCards.forEach(({ card }) => {
                    if (card && card.goat) {
                        const has90Plus = lockedCards.some(lc => lc !== card && lc.ovr >= 90);
                        if (!has90Plus) {
                            goatBonus = 4;
                        }
                    }
                });
            }
            
            // In online mode, only show your own hand
            if (onlineGame.enabled && onlineGame.gamePlayerId !== undefined) {
                showHand = (player.id === onlineGame.gamePlayerId);
            }
            
            // Determine if this is the viewing player's own area
            const isOwnView = (gameState.viewMode === 'separate' && player.id === gameState.currentView) || 
                             (gameState.viewMode === 'shared') ||
                             (onlineGame.enabled && onlineGame.gamePlayerId !== undefined && player.id === onlineGame.gamePlayerId);
            
            // Hide Team OVR for other players during captain selection
            const showTeamOVR = gameState.phase !== 'captainSelection' || isOwnView;
            
            playerDiv.innerHTML = `
                <div class="player-header">
                    <div class="player-name">${player.name}${gameState.viewMode === 'separate' && player.id === gameState.currentView ? ' (YOU)' : ''}${onlineGame.enabled && onlineGame.gamePlayerId !== undefined && player.id === onlineGame.gamePlayerId ? ' (YOU)' : ''}</div>
                    <div class="team-ovr">
                        ${showTeamOVR ? `${teamOVR} OVR` : '??? OVR'}
                        ${showTeamOVR && goatBonus > 0 ? `<span style="color: #ff69b4; font-size: 0.8em; margin-left: 5px;">üêê+${goatBonus}</span>` : ''}
                        ${showTeamOVR && teamBonus > 0 ? `<span style="color: #ffd700; font-size: 0.8em; margin-left: 5px;">üèÜ+${teamBonus}</span>` : ''}
                        ${showTeamOVR && eraBonus > 0 ? `<span style="color: #90EE90; font-size: 0.8em; margin-left: 5px;">üìÖ+${eraBonus}</span>` : ''}
                    </div>
                </div>
                <div class="lineup" id="lineup-${player.id}"></div>
                ${showHand ? `<div class="hand">
                    <div class="hand-title">Hand (${player.hand.length} cards)</div>
                    <div class="hand-cards" id="hand-${player.id}"></div>
                </div>` : `<div class="hand">
                    <div class="hand-title">Hand: ${player.hand.length} cards (hidden)</div>
                </div>`}
            `;
            
            container.appendChild(playerDiv);
            
            // Render lineup
            renderLineup(player);
            
            // Render hand only if showHand is true
            if (showHand) {
                renderHand(player);
            }
        }

        function renderLineup(player) {
            const lineupDiv = document.getElementById(`lineup-${player.id}`);
            lineupDiv.innerHTML = '';

            POSITIONS.forEach(pos => {
                const slot = document.createElement('div');
                slot.className = 'position-slot';
                
                // Make slots clickable during captain selection or when locking in cards (NOT for AI players)
                const isCurrentPlayer = !player.isAI && (player.id === gameState.currentPlayerIndex || gameState.phase === 'captainSelection');
                const cardToPlace = gameState.phase === 'captainSelection' ? player.captain : 
                                   (isCurrentPlayer ? gameState.selectedCard : null);
                
                // Don't allow locking in if waiting for burn OR if player hasn't asked yet
                const canLockIn = gameState.waitingForBurn === null && 
                                 (gameState.phase === 'captainSelection' || gameState.hasAsked);
                
                if (isCurrentPlayer && !player.lineup[pos] && cardToPlace && canLockIn) {
                    // During captain selection, only allow if captain hasn't been placed yet
                    if (gameState.phase === 'captainSelection' && player.captainHidden) {
                        // Captain already placed, don't make slots clickable
                    } else if (canPlaceCardAtPosition(cardToPlace, pos)) {
                        slot.style.cursor = 'pointer';
                        slot.style.borderColor = 'rgba(255, 215, 0, 0.8)';
                        slot.style.borderStyle = 'solid';
                        slot.onclick = () => placeCardInPosition(player.id, pos);
                        
                        // Show if there would be a penalty
                        const penalty = calculatePositionPenalty(cardToPlace, pos);
                        if (penalty > 0) {
                            const penaltyHint = document.createElement('div');
                            penaltyHint.style.cssText = 'font-size: 0.7em; color: #ff9999; position: absolute; top: 5px; right: 5px;';
                            penaltyHint.textContent = `-${penalty}`;
                            slot.style.position = 'relative';
                            slot.appendChild(penaltyHint);
                        }
                    }
                }
                
                const label = document.createElement('div');
                label.className = 'position-label';
                label.textContent = pos;
                slot.appendChild(label);

                const card = player.lineup[pos];
                if (card) {
                    // During captain selection, hide OTHER players' captain cards until all are placed
                    const isOwnView = (gameState.viewMode === 'separate' && player.id === gameState.currentView) || 
                                     (gameState.viewMode === 'shared') ||
                                     (onlineGame.enabled && onlineGame.gamePlayerId !== undefined && player.id === onlineGame.gamePlayerId);
                    
                    if (gameState.phase === 'captainSelection' && card === player.captain && !isOwnView) {
                        const hiddenDiv = document.createElement('div');
                        hiddenDiv.style.cssText = 'padding: 15px; text-align: center; background: rgba(0,0,0,0.5); border-radius: 8px;';
                        hiddenDiv.innerHTML = `
                            <div style="font-size: 1.5em;">üÉè</div>
                            <div style="font-size: 0.7em; margin-top: 5px; color: #ffd700;">CAPTAIN</div>
                            <div style="font-size: 0.6em; color: #888;">Hidden</div>
                        `;
                        slot.appendChild(hiddenDiv);
                    } else {
                        const cardDiv = createCardElement(card, false);
                        
                        // Show if card is out of position
                        if (!card.positions.includes(pos)) {
                            const penalty = calculatePositionPenalty(card, pos);
                            if (penalty > 0) {
                                const penaltyLabel = document.createElement('div');
                                penaltyLabel.style.cssText = 'font-size: 0.7em; color: #ff9999; margin-top: 5px;';
                                penaltyLabel.textContent = `-${penalty} OVR`;
                                cardDiv.appendChild(penaltyLabel);
                            }
                        }
                        
                        if (card === player.captain) {
                            const captainLabel = document.createElement('div');
                            captainLabel.style.cssText = 'font-size: 0.7em; margin-top: 5px; color: #ffd700;';
                            captainLabel.textContent = '‚≠ê CAPTAIN';
                            cardDiv.appendChild(captainLabel);
                        }
                        
                        slot.appendChild(cardDiv);
                    }
                }

                lineupDiv.appendChild(slot);
            });
        }

        function placeCardInPosition(playerId, position) {
            const player = gameState.players[playerId];
            
            if (gameState.phase === 'captainSelection' && player.captain && !player.captainHidden) {
                // Check if captain is already placed somewhere
                const alreadyPlaced = Object.values(player.lineup).some(c => c === player.captain);
                if (alreadyPlaced) {
                    showMessage("Captain is already placed!");
                    return;
                }
                
                // Check if card can be placed in this position
                if (!canPlaceCardAtPosition(player.captain, position)) {
                    showMessage(`${player.captain.name} cannot be placed at ${position}!`);
                    return;
                }
                
                // Place captain in chosen position
                if (!player.lineup[position]) {
                    player.lineup[position] = player.captain;
                    player.captainHidden = true; // Mark as placed to remove highlights
                    
                    // Sync to Firebase in online mode
                    if (onlineGame.enabled) {
                        syncCaptainToFirebase(playerId, player.captain, position);
                    }
                    
                    updateDisplay();
                    
                    // Check if all captains are placed
                    const allPlaced = gameState.players.every(p => 
                        p.captain && Object.values(p.lineup).some(card => card === p.captain)
                    );
                    
                    if (allPlaced) {
                        revealCaptains();
                    } else {
                        // Find next player who needs to place
                        const nextPlayer = gameState.players.find(p => 
                            p.captain && !Object.values(p.lineup).some(card => card === p.captain)
                        );
                        if (nextPlayer) {
                            showMessage(`${player.name} placed their captain! ${nextPlayer.name}, click a position slot to place your captain.`);
                        }
                    }
                }
            } else if (gameState.phase === 'playing' && playerId === gameState.currentPlayerIndex && gameState.selectedCard) {
                // Check if card is already placed somewhere
                const alreadyPlaced = Object.values(player.lineup).some(c => c === gameState.selectedCard);
                if (alreadyPlaced) {
                    showMessage("This card is already placed in your lineup!");
                    return;
                }
                
                // Check if card can be placed in this position
                if (!canPlaceCardAtPosition(gameState.selectedCard, position)) {
                    showMessage(`${gameState.selectedCard.name} cannot be placed at ${position}!`);
                    return;
                }
                
                // Lock in selected card to chosen position
                if (!player.lineup[position]) {
                    const card = gameState.selectedCard;
                    player.lineup[position] = card;
                    player.hand = player.hand.filter(c => c !== card);
                    gameState.selectedCard = null;
                    gameState.selectedCardPlayer = undefined;

                    // Give highest rank card (best card, lowest rank number) to player counterclockwise
                    let drawnCard = null;
                    if (player.hand.length > 0) {
                        const highestCard = player.hand.reduce((max, card) => 
                            card.rank < max.rank ? card : max
                        );
                        
                        const nextPlayerIndex = (gameState.currentPlayerIndex - 1 + gameState.players.length) % gameState.players.length;
                        const nextPlayer = gameState.players[nextPlayerIndex];
                        
                        player.hand = player.hand.filter(c => c !== highestCard);
                        nextPlayer.hand.push(highestCard);
                        
                        // Mark this card as newly acquired for the next player
                        gameState.newlyAcquiredCard = highestCard;
                        
                        // Current player draws before ending turn
                        if (gameState.deck.length > 0) {
                            drawnCard = gameState.deck.pop();
                            player.hand.push(drawnCard);
                        }
                        
                        // Sync to Firebase
                        if (onlineGame.enabled) {
                            const updates = {};
                            updates[`lineups/${playerId}/${position}`] = card.rank;
                            updates[`hands/${playerId}`] = player.hand.map(c => c.rank);
                            updates[`hands/${nextPlayerIndex}`] = nextPlayer.hand.map(c => c.rank);
                            if (drawnCard) {
                                updates.deckIndex = CARDS.length - gameState.deck.length;
                            }
                            updates.waitingForBurn = nextPlayerIndex;
                            syncToFirebase(updates);
                        }
                        
                        // Never reveal which card was given - only reveal the locked card
                        showMessage(`${player.name} locked in ${card.name}! ${nextPlayer.name} received a card and must burn one.`);
                        gameState.waitingForBurn = nextPlayerIndex;
                        gameState.playerNeedingAction = nextPlayerIndex;
                        
                        // If next player is AI, auto-burn (aiBurnCard has built-in delay)
                        if (nextPlayer.isAI) {
                            aiBurnCard(nextPlayer);
                        }
                    } else {
                        // No cards to give, just draw
                        if (gameState.deck.length > 0) {
                            drawnCard = gameState.deck.pop();
                            player.hand.push(drawnCard);
                        }
                        
                        // Sync to Firebase
                        if (onlineGame.enabled) {
                            const updates = {};
                            updates[`lineups/${playerId}/${position}`] = card.rank;
                            updates[`hands/${playerId}`] = player.hand.map(c => c.rank);
                            if (drawnCard) {
                                updates.deckIndex = CARDS.length - gameState.deck.length;
                            }
                            syncToFirebase(updates);
                        }
                    }

                    // Check if player has 5 locked in
                    const lockedCount = Object.values(player.lineup).filter(c => c !== null).length;
                    if (lockedCount >= 5) {
                        endGame();
                        return;
                    }

                    updateDisplay();
                }
            }
        }

        function canPlaceCardAtPosition(card, targetPosition) {
            // LeBron James special ability - can go anywhere
            if (card.special === "anywhere") {
                return true;
            }
            
            const cardPos = card.positions[0];
            
            // Same position - always valid
            if (cardPos === targetPosition) {
                return true;
            }
            
            // Position adjacency rules:
            // PG can go to SG
            if (cardPos === "PG" && targetPosition === "SG") return true;
            
            // SG can go to PG or SF
            if (cardPos === "SG" && (targetPosition === "PG" || targetPosition === "SF")) return true;
            
            // SF can go to SG or PF
            if (cardPos === "SF" && (targetPosition === "SG" || targetPosition === "PF")) return true;
            
            // PF can go to SF or C
            if (cardPos === "PF" && (targetPosition === "SF" || targetPosition === "C")) return true;
            
            // C can go to PF
            if (cardPos === "C" && targetPosition === "PF") return true;
            
            return false;
        }

        function calculatePositionPenalty(card, pos) {
            if (card.positions.includes(pos)) return 0;
            
            if (card.goat && card.name === "LeBron James" && pos !== "SF") {
                return 4;
            } else if ((card.positions.includes("SG") || card.positions.includes("SF") || card.positions.includes("PF")) &&
                       Math.abs(POSITIONS.indexOf(card.positions[0]) - POSITIONS.indexOf(pos)) === 1) {
                return 6;
            } else if (card.positions.includes("PG") && pos === "SG") {
                return 4;
            } else if (card.positions.includes("C") && pos === "PF") {
                return 4;
            }
            
            return 0; // Invalid position, but return 0 for now
        }

        function renderHand(player) {
            const handDiv = document.getElementById(`hand-${player.id}`);
            handDiv.innerHTML = '';

            player.hand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'hand-card';
                
                // Check if this is the newly acquired card
                const isNewCard = gameState.newlyAcquiredCard === card;
                
                // Calculate potential bonuses for this card
                const bonuses = calculatePotentialBonuses(player, card);
                const hasBonuses = bonuses.total > 0;
                
                // Check if this card is LeBron or Jordan and qualifies for GOAT bonus
                let hasGoatBonus = false;
                if (card.goat) {
                    const lockedCards = [];
                    POSITIONS.forEach(pos => {
                        if (player.lineup[pos]) {
                            lockedCards.push(player.lineup[pos]);
                        }
                    });
                    const has90Plus = lockedCards.some(lc => lc !== card && lc.ovr >= 90);
                    if (!has90Plus) {
                        hasGoatBonus = true;
                    }
                }
                
                // Color based on OVR rating - NEW RARITY SYSTEM
                let cardColor = '';
                if (card.ovr >= 92) cardColor = 'linear-gradient(135deg, #9B59B6 0%, #8E44AD 100%)'; // Amethyst
                else if (card.ovr >= 87) cardColor = 'linear-gradient(135deg, #E74C3C 0%, #C0392B 100%)'; // Ruby
                else if (card.ovr >= 83) cardColor = 'linear-gradient(135deg, #2ECC71 0%, #27AE60 100%)'; // Emerald
                else if (card.ovr >= 80) cardColor = 'linear-gradient(135deg, #3498DB 0%, #2980B9 100%)'; // Diamond
                else if (card.ovr >= 78) cardColor = 'linear-gradient(135deg, #DAA520 0%, #B8860B 100%)'; // Gold (darker)
                else if (card.ovr >= 76) cardColor = 'linear-gradient(135deg, #A9A9A9 0%, #808080 100%)'; // Silver (darker)
                else if (card.ovr === 70) cardColor = 'linear-gradient(135deg, #696969 0%, #4B4B4B 100%)'; // Benchwarmer (dark gray)
                else cardColor = 'linear-gradient(135deg, #CD7F32 0%, #8B4513 100%)'; // Bronze
                
                cardDiv.style.background = cardColor;
                
                // Special styling for newly acquired card
                if (isNewCard) {
                    cardDiv.style.borderColor = '#00ffff';
                    cardDiv.style.borderWidth = '4px';
                    cardDiv.style.borderStyle = 'solid';
                    cardDiv.style.boxShadow = '0 0 20px #00ffff';
                    cardDiv.style.animation = 'pulse 1.5s infinite';
                }
                
                // Disable selection if player already has a captain (during captain selection)
                if (gameState.phase === 'captainSelection' && player.captain) {
                    cardDiv.style.opacity = '0.5';
                    cardDiv.style.cursor = 'not-allowed';
                } else if (gameState.waitingForBurn === player.id) {
                    // This player needs to select a card to burn
                    if (gameState.selectedCard === card && gameState.selectedCardPlayer === player.id) {
                        cardDiv.className += ' selected';
                    }
                    cardDiv.onclick = () => selectCard(player.id, card);
                } else {
                    if (gameState.selectedCard === card && gameState.selectedCardPlayer === player.id) {
                        cardDiv.className += ' selected';
                    }
                    cardDiv.onclick = () => selectCard(player.id, card);
                }
                
                cardDiv.innerHTML = `
                    <div style="font-size: 0.75em; font-weight: bold;">${card.name}</div>
                    <div style="font-size: 1.3em; font-weight: bold; margin: 5px 0;">${card.ovr}</div>
                    <div style="font-size: 0.65em;">${card.positions.join('/')}</div>
                    <div style="font-size: 0.6em; color: rgba(255,255,255,0.8); margin-top: 3px;">${card.primary} | E${card.era}</div>
                    <div style="font-size: 0.6em; color: rgba(255,255,255,0.7); margin-top: 2px;">#${card.rank}</div>
                    ${isNewCard ? '<div style="font-size: 0.65em; color: #00ffff; margin-top: 3px; font-weight: bold;">‚≠ê NEW ‚≠ê</div>' : ''}
                    ${hasGoatBonus ? '<div style="font-size: 0.65em; color: #ff69b4; margin-top: 3px; font-weight: bold;">üêê+4</div>' : ''}
                    ${bonuses.total > 0 ? `<div style="font-size: 0.65em; color: #00ff00; margin-top: 3px; font-weight: bold;">${bonuses.teamChemistry > 0 ? 'üèÜ+' + bonuses.teamChemistry : ''}${bonuses.teamChemistry > 0 && bonuses.era > 0 ? ' ' : ''}${bonuses.era > 0 ? 'üìÖ+' + bonuses.era : ''}</div>` : ''}
                `;
                
                handDiv.appendChild(cardDiv);
            });
        }

        function burnCard(playerId, card) {
            const player = gameState.players[playerId];
            player.hand = player.hand.filter(c => c !== card);
            gameState.burnPile.unshift(card);
            if (gameState.burnPile.length > 10) {
                gameState.burnPile = gameState.burnPile.slice(0, 10);
            }
            gameState.waitingForBurn = null;
            gameState.selectedCard = null;
            gameState.selectedCardPlayer = undefined;
            gameState.playerNeedingAction = null;
            
            // Sync to Firebase
            if (onlineGame.enabled) {
                const updates = {};
                updates[`hands/${playerId}`] = player.hand.map(c => c.rank);
                updates.burnPile = gameState.burnPile.slice(0, 10).map(c => c.rank);
                updates.waitingForBurn = null;
                
                // Check who was burning
                if (playerId !== gameState.currentPlayerIndex) {
                    // Turn changes
                    const lockerIndex = (playerId + 1) % gameState.players.length;
                    const nextIndex = (lockerIndex + 1) % gameState.players.length;
                    updates.currentPlayerIndex = nextIndex;
                    updates.hasAsked = false;
                }
                
                syncToFirebase(updates);
            }
            
            // Check who was burning
            if (playerId === gameState.currentPlayerIndex) {
                // Current player burned after asking - they can now lock in or end turn
                updateBurnPile();
                updateDisplay();
                showMessage(`${player.name} burned ${card.name}. You can now lock in a card or end your turn.`);
            } else {
                // Another player burned after receiving a card from lock-in
                // Turn goes CLOCKWISE from the player who locked in (not the burner)
                // Find who locked in (the player before the burner counterclockwise)
                const lockerIndex = (playerId + 1) % gameState.players.length;
                const nextIndex = (lockerIndex + 1) % gameState.players.length;
                
                gameState.currentPlayerIndex = nextIndex;
                gameState.hasAsked = false;
                gameState.newlyAcquiredCard = null; // Clear after burning player has seen it
                updateBurnPile();
                updateDisplay();
                showMessage(`${player.name} burned ${card.name}. It's now ${gameState.players[nextIndex].name}'s turn!`);
                
                // Check if new current player is AI
                if (gameState.players[nextIndex].isAI) {
                    aiTakeTurn(gameState.players[nextIndex]);
                }
            }
        }

        function confirmBurn() {
            if (!gameState.selectedCard || gameState.waitingForBurn === null) {
                showMessage("Please select a card from your hand to burn");
                return;
            }
            
            const playerId = gameState.waitingForBurn;
            const card = gameState.selectedCard;
            const player = gameState.players[playerId];
            
            // Make sure the selected card is in the burning player's hand
            if (!player.hand.includes(card)) {
                showMessage("You must select a card from your own hand!");
                return;
            }
            
            burnCard(playerId, card);
        }

        function createCardElement(card, showDetails = true) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${card.positions[0].toLowerCase()}`;
            
            // Color based on OVR rating - NEW RARITY SYSTEM
            let cardColor = '';
            if (card.ovr >= 92) cardColor = 'linear-gradient(135deg, #9B59B6 0%, #8E44AD 100%)'; // Amethyst
            else if (card.ovr >= 87) cardColor = 'linear-gradient(135deg, #E74C3C 0%, #C0392B 100%)'; // Ruby
            else if (card.ovr >= 83) cardColor = 'linear-gradient(135deg, #2ECC71 0%, #27AE60 100%)'; // Emerald
            else if (card.ovr >= 80) cardColor = 'linear-gradient(135deg, #3498DB 0%, #2980B9 100%)'; // Diamond
            else if (card.ovr >= 78) cardColor = 'linear-gradient(135deg, #DAA520 0%, #B8860B 100%)'; // Gold
            else if (card.ovr >= 76) cardColor = 'linear-gradient(135deg, #A9A9A9 0%, #808080 100%)'; // Silver
            else cardColor = 'linear-gradient(135deg, #CD7F32 0%, #8B4513 100%)'; // Bronze
            
            cardDiv.style.background = cardColor;
            
            cardDiv.innerHTML = `
                <div class="card-position">${card.positions.join('/')} - ${card.primary} - ERA ${card.era}</div>
                <div class="card-name">${card.name}</div>
                <div class="card-ovr">${card.ovr}</div>
                <div class="card-rank">#${card.rank}</div>
            `;
            
            return cardDiv;
        }

        function selectCard(playerId, card) {
            // In separate mode during captain selection, allow any player to select their captain
            if (gameState.phase === 'captainSelection') {
                // Only allow selection if this player hasn't set a captain yet
                const player = gameState.players[playerId];
                if (player.captain) {
                    showMessage(`${player.name} has already selected a captain!`);
                    return;
                }
                gameState.selectedCard = card;
                gameState.selectedCardPlayer = playerId;
                updateDisplay();
            } else if (gameState.phase === 'playing') {
                // In separate mode, only allow selecting from current view's hand
                if (gameState.viewMode === 'separate' && playerId !== gameState.currentView) {
                    showMessage("Switch to your view to select cards!");
                    return;
                }
                
                // Allow selection if it's your turn OR if you're waiting to burn a card
                if (playerId === gameState.currentPlayerIndex || playerId === gameState.waitingForBurn) {
                    gameState.selectedCard = card;
                    gameState.selectedCardPlayer = playerId;
                    updateDisplay();
                }
            }
        }

        function setCaptain() {
            if (!gameState.selectedCard || gameState.selectedCardPlayer === undefined) return;
            
            const player = gameState.players[gameState.selectedCardPlayer];
            
            // Check if player already has a captain
            if (player.captain) {
                showMessage(`${player.name} has already selected a captain!`);
                return;
            }
            
            player.captain = gameState.selectedCard;
            player.hand = player.hand.filter(c => c !== gameState.selectedCard);
            
            // Clear selection state for next player
            gameState.selectedCard = null;
            gameState.selectedCardPlayer = undefined;
            
            updateDisplay();
            
            // Check if all captains are selected
            const allCaptainsSelected = gameState.players.every(p => p.captain);
            if (allCaptainsSelected) {
                showMessage(`${player.name} selected their captain! All captains selected. Now click a position slot to place your captain.`);
            } else {
                // Find next player who needs to select
                const nextPlayer = gameState.players.find(p => !p.captain);
                showMessage(`${player.name} selected their captain and must place it. ${nextPlayer.name}, select your captain!`);
            }
        }

        function revealCaptains() {
            // Check if all captains have been placed in positions
            const allPlaced = gameState.players.every(p => {
                if (!p.captain) return false;
                return Object.values(p.lineup).some(card => card && card === p.captain);
            });

            if (!allPlaced) {
                showMessage("All players must place their captains in a position slot!");
                return;
            }

            showMessage("All captains placed! Revealing...");
            
            setTimeout(() => {
                gameState.players.forEach(player => {
                    player.captainHidden = true;
                });

                // Determine first player (HIGHEST rank number = worst captain)
                let highestRank = -Infinity;
                let firstPlayerIndex = 0;
                gameState.players.forEach((player, index) => {
                    if (player.captain && player.captain.rank > highestRank) {
                        highestRank = player.captain.rank;
                        firstPlayerIndex = index;
                    }
                });

                gameState.currentPlayerIndex = firstPlayerIndex;
                gameState.phase = 'playing';
                
                // Sync phase change to Firebase (only host does this)
                if (onlineGame.enabled && onlineGame.isHost) {
                    syncToFirebase({
                        phase: 'playing',
                        currentPlayerIndex: firstPlayerIndex
                    });
                }
                
                updateDisplay();
                showMessage(`${gameState.players[firstPlayerIndex].name} has the lowest rank captain (#${highestRank}) and goes first!`);
                
                // Check if first player is AI
                const firstPlayer = gameState.players[firstPlayerIndex];
                if (firstPlayer.isAI) {
                    setTimeout(() => {
                        aiTakeTurn(firstPlayer);
                    }, 2000);
                }
            }, 1000);
        }

        function getCardPosition(card) {
            return card.positions[0];
        }

        function calculatePotentialBonuses(player, newCard) {
            const lockedCards = [];
            POSITIONS.forEach(pos => {
                if (player.lineup[pos]) {
                    lockedCards.push(player.lineup[pos]);
                }
            });
            
            // Calculate CURRENT bonuses (without the new card) - STACKING
            let currentTeamBonus = 0;
            let currentEraBonus = 0;
            
            if (lockedCards.length > 0) {
                // Current team chemistry - STACKING
                const currentTeamCounts = {};
                lockedCards.forEach(card => {
                    currentTeamCounts[card.primary] = (currentTeamCounts[card.primary] || 0) + 1;
                });
                Object.values(currentTeamCounts).forEach(count => {
                    if (count === 2) currentTeamBonus += 2;
                    else if (count === 3) currentTeamBonus += 4;
                    else if (count === 4) currentTeamBonus += 8;
                    else if (count >= 5) currentTeamBonus += 16;
                });
                
                // Current era bonus - STACKING
                const currentEraCounts = {};
                lockedCards.forEach(card => {
                    card.era.split(', ').forEach(era => {
                        currentEraCounts[era] = (currentEraCounts[era] || 0) + 1;
                    });
                });
                Object.values(currentEraCounts).forEach(count => {
                    if (count === 3) currentEraBonus += 2;
                    else if (count === 4) currentEraBonus += 4;
                    else if (count >= 5) currentEraBonus += 8;
                });
            }
            
            // Calculate NEW bonuses (with the new card added) - STACKING
            const simulatedCards = [...lockedCards, newCard];
            let newTeamBonus = 0;
            let newEraBonus = 0;
            
            // New team chemistry - STACKING
            const teamCounts = {};
            simulatedCards.forEach(card => {
                teamCounts[card.primary] = (teamCounts[card.primary] || 0) + 1;
            });
            Object.values(teamCounts).forEach(count => {
                if (count === 2) newTeamBonus += 2;
                else if (count === 3) newTeamBonus += 4;
                else if (count === 4) newTeamBonus += 8;
                else if (count >= 5) newTeamBonus += 16;
            });
            
            // New era bonus - STACKING
            const eraCounts = {};
            simulatedCards.forEach(card => {
                card.era.split(', ').forEach(era => {
                    eraCounts[era] = (eraCounts[era] || 0) + 1;
                });
            });
            Object.values(eraCounts).forEach(count => {
                if (count === 3) newEraBonus += 2;
                else if (count === 4) newEraBonus += 4;
                else if (count >= 5) newEraBonus += 8;
            });
            
            // Return ONLY the INCREASE
            return {
                teamChemistry: newTeamBonus - currentTeamBonus,
                era: newEraBonus - currentEraBonus,
                total: (newTeamBonus - currentTeamBonus) + (newEraBonus - currentEraBonus)
            };
        }

        function calculateTeamOVR(player) {
            let total = 0;
            let lockedCards = [];
            
            POSITIONS.forEach(pos => {
                const card = player.lineup[pos];
                if (card) {
                    lockedCards.push({ card, pos });
                    total += card.ovr;
                    
                    // Position penalties
                    if (!card.positions.includes(pos)) {
                        if (card.goat && card.name === "LeBron James" && pos !== "SF") {
                            total -= 4;
                        } else if ((card.positions.includes("SG") || card.positions.includes("SF") || card.positions.includes("PF")) &&
                                   Math.abs(POSITIONS.indexOf(card.positions[0]) - POSITIONS.indexOf(pos)) === 1) {
                            total -= 6;
                        } else if (card.positions.includes("PG") && pos === "SG") {
                            total -= 4;
                        } else if (card.positions.includes("C") && pos === "PF") {
                            total -= 4;
                        }
                    }
                }
            });

            // GOAT bonus
            lockedCards.forEach(({ card }) => {
                if (card.goat) {
                    const has90Plus = lockedCards.some(lc => lc.card !== card && lc.card.ovr >= 90);
                    if (!has90Plus) {
                        total += 4;
                    }
                }
            });

            // Team chemistry - STACKING across multiple teams
            const teamCounts = {};
            lockedCards.forEach(({ card }) => {
                teamCounts[card.primary] = (teamCounts[card.primary] || 0) + 1;
            });
            
            // Add bonus for each team group
            Object.values(teamCounts).forEach(count => {
                if (count === 2) total += 2;
                else if (count === 3) total += 4;
                else if (count === 4) total += 8;
                else if (count >= 5) total += 16;
            });

            // Era bonus - STACKING across multiple eras
            const eraCounts = {};
            lockedCards.forEach(({ card }) => {
                card.era.split(', ').forEach(era => {
                    eraCounts[era] = (eraCounts[era] || 0) + 1;
                });
            });
            
            // Add bonus for each era group
            Object.values(eraCounts).forEach(count => {
                if (count === 3) total += 2;
                else if (count === 4) total += 4;
                else if (count >= 5) total += 8;
            });

            return total;
        }

        function updateControls() {
            const controlsDiv = document.getElementById('controlsContent');
            
            // Add view switcher for separate mode - ONLY HUMAN PLAYERS
            let viewSwitcher = '';
            if (gameState.viewMode === 'separate') {
                const humanPlayers = gameState.players.filter(p => !p.isAI);
                if (humanPlayers.length > 1) {
                    viewSwitcher = `
                        <div style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <h4 style="margin-bottom: 10px;">Switch View:</h4>
                            ${humanPlayers.map(p => 
                                `<button onclick="switchView(${p.id})" ${gameState.currentView === p.id ? 'style="background: #00ff00; color: black;"' : ''}>${p.name}</button>`
                            ).join('')}
                        </div>
                    `;
                }
            }
            
            if (gameState.phase === 'captainSelection') {
                const currentPlayer = gameState.players[0]; // Show for all players
                controlsDiv.innerHTML = viewSwitcher + `
                    <p>Select your captain from your hand</p>
                    <button onclick="setCaptain()" ${!gameState.selectedCard ? 'disabled' : ''}>Set Captain</button>
                    <p style="margin-top: 10px; font-size: 0.9em;">Captains selected: ${gameState.players.filter(p => p.captain).length}/${gameState.players.length}</p>
                `;
            } else if (gameState.phase === 'playing') {
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                
                if (gameState.waitingForBurn !== null) {
                    const burningPlayer = gameState.players[gameState.waitingForBurn];
                    // Disable buttons if burner is AI
                    const isAI = burningPlayer.isAI;
                    controlsDiv.innerHTML = viewSwitcher + `
                        <h3>${burningPlayer.name} Must Burn a Card</h3>
                        ${isAI ? '<p>AI is thinking...</p>' : '<p>Select a card from your hand, then click Burn Card</p>'}
                        <button onclick="confirmBurn()" ${!gameState.selectedCard || isAI ? 'disabled' : ''} style="background: #ff0000; color: white;">Burn Card</button>
                    `;
                } else {
                    // Disable buttons if current player is AI
                    const isAI = currentPlayer.isAI;
                    controlsDiv.innerHTML = viewSwitcher + `
                        <h3>${currentPlayer.name}'s Turn</h3>
                        ${isAI ? '<p style="margin-top: 15px;">AI is thinking...</p>' : ''}
                        <div style="margin-top: 15px;">
                            <button onclick="askForPosition()" ${gameState.hasAsked || isAI ? 'disabled' : ''}>Ask for Position</button>
                            <button onclick="endTurn()" ${isAI ? 'disabled' : ''}>End Turn</button>
                        </div>
                        ${!isAI && gameState.hasAsked ? '<p style="margin-top: 10px; font-size: 0.9em; color: #aaa;">Select a card from your hand, then click a position slot to lock it in</p>' : ''}
                        ${!isAI && !gameState.hasAsked ? '<p style="margin-top: 10px; font-size: 0.9em; color: #aaa;">Click "Ask for Position" to request a card from an opponent</p>' : ''}
                    `;
                }
            }
        }

        function switchView(playerIndex) {
            gameState.currentView = playerIndex;
            gameState.selectedCard = null; // Clear selection when switching views
            updateDisplay();
        }

        function askForPosition() {
            const modal = document.getElementById('modalBody');
            
            // Reset selections when opening modal
            gameState.positionAsked = null;
            gameState.targetPlayer = null;
            
            updateAskModal();
            showModal('Ask for Position');
        }

        function updateAskModal() {
            const modal = document.getElementById('modalBody');
            modal.innerHTML = `
                <p><strong>Step 1:</strong> Select a position to ask for:</p>
                <div style="margin: 10px 0;">
                    ${POSITIONS.map(pos => 
                        `<button onclick="selectPosition('${pos}')" 
                            style="${gameState.positionAsked === pos ? 'background: #00ff00; color: black;' : ''}"
                        >${pos}</button>`
                    ).join('')}
                </div>
                <br>
                <p><strong>Step 2:</strong> Select which player to ask:</p>
                <div style="margin: 10px 0;">
                    ${gameState.players.map((p, i) => 
                        i !== gameState.currentPlayerIndex ? 
                        `<button onclick="selectTargetPlayer(${i})"
                            style="${gameState.targetPlayer === i ? 'background: #00ff00; color: black;' : ''}"
                        >${p.name}</button>` : ''
                    ).join('')}
                </div>
                ${gameState.positionAsked && gameState.targetPlayer !== null ? 
                    '' : 
                    '<p style="color: #aaa; font-style: italic; margin-top: 15px;">Select both a position and a player to continue</p>'}
            `;
        }

        function selectPosition(pos) {
            gameState.positionAsked = pos;
            updateAskModal();
            // Auto-execute if both are selected
            if (gameState.targetPlayer !== null) {
                executeAsk();
            }
        }

        function selectTargetPlayer(playerIndex) {
            gameState.targetPlayer = playerIndex;
            updateAskModal();
            // Auto-execute if both are selected
            if (gameState.positionAsked) {
                executeAsk();
            }
        }

        function executeAsk() {
            const targetPlayer = gameState.players[gameState.targetPlayer];
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const pos = gameState.positionAsked;

            // Find cards with that position
            const matchingCards = targetPlayer.hand.filter(card => card.positions.includes(pos));
            
            if (matchingCards.length > 0) {
                // Give highest OVR card (lowest rank number)
                matchingCards.sort((a, b) => a.rank - b.rank);
                const cardToGive = matchingCards[0];
                
                targetPlayer.hand = targetPlayer.hand.filter(c => c !== cardToGive);
                currentPlayer.hand.push(cardToGive);
                
                // Track the newly acquired card
                gameState.newlyAcquiredCard = cardToGive;
                
                // Never reveal which card was given - keep it secret
                showMessage(`${targetPlayer.name} gave ${currentPlayer.name} a card.`);
                
                // Target player draws a card
                let drawnCard = null;
                if (gameState.deck.length > 0) {
                    drawnCard = gameState.deck.pop();
                    targetPlayer.hand.push(drawnCard);
                }

                // Sync to Firebase
                if (onlineGame.enabled) {
                    const updates = {};
                    updates[`hands/${gameState.currentPlayerIndex}`] = currentPlayer.hand.map(c => c.rank);
                    updates[`hands/${gameState.targetPlayer}`] = targetPlayer.hand.map(c => c.rank);
                    if (drawnCard) {
                        updates.deckIndex = CARDS.length - gameState.deck.length;
                    }
                    updates.hasAsked = true;
                    updates.waitingForBurn = gameState.currentPlayerIndex;
                    syncToFirebase(updates);
                }

                closeModal();
                gameState.targetPlayer = null;
                gameState.positionAsked = null;
                gameState.hasAsked = true;
                
                // Current player must now burn a card
                gameState.waitingForBurn = gameState.currentPlayerIndex;
                gameState.playerNeedingAction = gameState.currentPlayerIndex;
                
                // If current player is AI, auto-burn (aiBurnCard has built-in delay)
                if (currentPlayer.isAI) {
                    aiBurnCard(currentPlayer);
                } else {
                    showMessage(`${currentPlayer.name}, select a card from your hand and click "Burn Card"`);
                }
                updateDisplay();
            } else {
                // No matching cards - no burn needed
                showMessage(`${targetPlayer.name} has no ${pos} cards! ${currentPlayer.name} can now lock in a card or end their turn.`);
                
                // Target player still draws a card
                let drawnCard = null;
                if (gameState.deck.length > 0) {
                    drawnCard = gameState.deck.pop();
                    targetPlayer.hand.push(drawnCard);
                }
                
                // Sync to Firebase
                if (onlineGame.enabled) {
                    const updates = {};
                    updates[`hands/${gameState.targetPlayer}`] = targetPlayer.hand.map(c => c.rank);
                    if (drawnCard) {
                        updates.deckIndex = CARDS.length - gameState.deck.length;
                    }
                    updates.hasAsked = true;
                    syncToFirebase(updates);
                }
                
                closeModal();
                gameState.targetPlayer = null;
                gameState.positionAsked = null;
                gameState.hasAsked = true;
                
                // No burn required - player can proceed
                updateDisplay();
            }
        }

        function endTurn() {
            const prevPlayer = gameState.players[gameState.currentPlayerIndex];
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            gameState.selectedCard = null;
            gameState.hasAsked = false; // Reset for next turn
            // Don't clear newlyAcquiredCard here - it persists until the receiving player burns
            
            // Sync to Firebase
            if (onlineGame.enabled) {
                syncToFirebase({
                    currentPlayerIndex: gameState.currentPlayerIndex,
                    hasAsked: false
                });
            }
            
            updateDisplay();
            
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            showMessage(`${prevPlayer.name} ended their turn. It's now ${currentPlayer.name}'s turn!`);
            
            // Check if next player is AI
            if (currentPlayer.isAI && gameState.phase === 'playing') {
                aiTakeTurn(currentPlayer);
            }
        }

        function updateBurnPile() {
            const burnDiv = document.getElementById('burnPile');
            burnDiv.innerHTML = '';
            
            gameState.burnPile.forEach(card => {
                const cardDiv = document.createElement('div');
                cardDiv.style.cssText = `
                    border-radius: 8px;
                    padding: 10px;
                    text-align: center;
                    min-width: 100px;
                    border: 2px solid rgba(255,255,255,0.3);
                `;
                
                // Color based on OVR rating
                let cardColor = '';
                if (card.ovr >= 92) cardColor = 'linear-gradient(135deg, #9B59B6 0%, #8E44AD 100%)'; // Amethyst
                else if (card.ovr >= 87) cardColor = 'linear-gradient(135deg, #E74C3C 0%, #C0392B 100%)'; // Ruby
                else if (card.ovr >= 83) cardColor = 'linear-gradient(135deg, #2ECC71 0%, #27AE60 100%)'; // Emerald
                else if (card.ovr >= 80) cardColor = 'linear-gradient(135deg, #3498DB 0%, #2980B9 100%)'; // Diamond
                else if (card.ovr >= 78) cardColor = 'linear-gradient(135deg, #DAA520 0%, #B8860B 100%)'; // Gold
                else if (card.ovr >= 76) cardColor = 'linear-gradient(135deg, #A9A9A9 0%, #808080 100%)'; // Silver
                else cardColor = 'linear-gradient(135deg, #CD7F32 0%, #8B4513 100%)'; // Bronze
                
                cardDiv.style.background = cardColor;
                
                cardDiv.innerHTML = `
                    <div style="font-size: 0.75em; font-weight: bold;">${card.name}</div>
                    <div style="font-size: 1.3em; font-weight: bold; margin: 5px 0;">${card.ovr}</div>
                    <div style="font-size: 0.65em;">${card.positions.join('/')}</div>
                    <div style="font-size: 0.6em; color: rgba(255,255,255,0.8); margin-top: 3px;">${card.primary} | E${card.era}</div>
                    <div style="font-size: 0.6em; color: rgba(255,255,255,0.7); margin-top: 2px;">#${card.rank}</div>
                `;
                
                burnDiv.appendChild(cardDiv);
            });
        }

        function endGame() {
            gameState.phase = 'final';
            
            // Fill empty positions with best available cards from hand
            gameState.players.forEach(player => {
                POSITIONS.forEach(pos => {
                    if (!player.lineup[pos]) {
                        // Find all cards in hand that can fill this position
                        const eligibleCards = player.hand.filter(card => 
                            canPlaceCardAtPosition(card, pos)
                        );
                        
                        if (eligibleCards.length > 0) {
                            // Calculate the best card considering OVR, penalties, and bonuses
                            let bestCard = null;
                            let bestScore = -Infinity;
                            
                            eligibleCards.forEach(card => {
                                // Temporarily place card to calculate bonuses
                                player.lineup[pos] = card;
                                const teamOVR = calculateTeamOVR(player);
                                player.lineup[pos] = null; // Remove temp placement
                                
                                // Score includes: card OVR - position penalty + team bonuses
                                const penalty = calculatePositionPenalty(card, pos);
                                const score = teamOVR; // This already includes everything
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestCard = card;
                                }
                            });
                            
                            if (bestCard) {
                                player.lineup[pos] = bestCard;
                                player.hand = player.hand.filter(c => c !== bestCard);
                            } else {
                                // No eligible cards, use benchwarmer
                                player.lineup[pos] = { name: "Benchwarmer", ovr: 70, positions: [pos], primary: "N/A", era: "0", rank: 999 };
                            }
                        } else {
                            // No eligible cards, use benchwarmer
                            player.lineup[pos] = { name: "Benchwarmer", ovr: 70, positions: [pos], primary: "N/A", era: "0", rank: 999 };
                        }
                    }
                });
            });

            // Calculate final scores
            const scores = gameState.players.map(player => ({
                player: player.name,
                ovr: calculateTeamOVR(player),
                playerId: player.id
            }));

            scores.sort((a, b) => b.ovr - a.ovr);
            
            const winner = scores[0];
            
            // Add winner class to winning player's area
            gameState.winnerPlayerId = winner.playerId;

            // Show winner in instruction area
            showMessage(`üèÜ ${winner.player} WINS with ${winner.ovr} Team OVR! üèÜ`);
            document.getElementById('instructionText').innerHTML = `
                <span style="font-size: 1.5em; color: #ffd700; font-weight: bold;">
                    üèÜ ${winner.player} is the CHAMPION! üèÜ
                </span><br>
                <span style="font-size: 1.2em; margin-top: 10px; display: block;">
                    Final Score: ${winner.ovr} Team OVR
                </span>
            `;

            const modal = document.getElementById('modalBody');
            modal.innerHTML = `
                <h2 style="color: #ffd700; text-align: center; font-size: 2em;">üèÜ Game Over! üèÜ</h2>
                <h3 style="color: #00ff00; text-align: center; font-size: 1.5em; margin-top: 20px;">Winner: ${winner.player}</h3>
                <div style="margin: 20px 0;">
                    <h4>Final Standings:</h4>
                    ${scores.map((s, i) => `
                        <div style="padding: 15px; margin: 8px 0; background: ${i === 0 ? 'linear-gradient(135deg, #DAA520 0%, #B8860B 100%)' : 'rgba(255,255,255,0.1)'}; border-radius: 8px; font-size: 1.1em;">
                            <strong>${i === 0 ? 'üëë ' : ''}${i + 1}. ${s.player}</strong>: ${s.ovr} Team OVR
                        </div>
                    `).join('')}
                </div>
                <button onclick="location.reload()" style="width: 100%; padding: 15px; font-size: 1.2em; margin-top: 10px;">üéÆ New Game</button>
            `;
            showModal('üèÜ Final Results');
            
            updateDisplay();
        }

        function showMessage(text) {
            document.getElementById('messageBox').textContent = text;
        }

        function aiSelectCaptain(player) {
            // AI picks highest OVR card as captain (with 2 second delay)
            setTimeout(() => {
                const bestCard = player.hand.reduce((best, card) => card.ovr > best.ovr ? card : best);
                player.captain = bestCard;
                player.hand = player.hand.filter(c => c !== bestCard);
                
                setTimeout(() => {
                    // AI places captain in best position
                    const validPositions = POSITIONS.filter(pos => canPlaceCardAtPosition(bestCard, pos));
                    if (validPositions.length > 0) {
                        // Prefer natural position
                        const naturalPos = validPositions.find(pos => bestCard.positions.includes(pos));
                        const chosenPos = naturalPos || validPositions[0];
                        player.lineup[chosenPos] = bestCard;
                        player.captainHidden = true; // Mark as placed
                        updateDisplay();
                    }
                }, 1500); // 1.5 second delay before placing
            }, 1500); // 1.5 second delay before selecting
        }

        function aiTakeTurn(player) {
            // AI strategy: Ask for positions it needs, then lock in best card with bonuses
            // Add 2-3 second delay to make AI moves visible
            setTimeout(() => {
                if (!gameState.hasAsked && Math.random() > 0.3) {
                    // AI asks for a position
                    const emptyPositions = POSITIONS.filter(pos => !player.lineup[pos]);
                    if (emptyPositions.length > 0) {
                        const askPos = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                        const targetIndex = Math.floor(Math.random() * gameState.players.length);
                        if (targetIndex !== player.id) {
                            gameState.positionAsked = askPos;
                            gameState.targetPlayer = targetIndex;
                            executeAsk();
                            
                            // After asking, AI might burn and lock in (2-3 second delays)
                            setTimeout(() => {
                                if (gameState.waitingForBurn === player.id) {
                                    aiBurnCard(player);
                                }
                                setTimeout(() => {
                                    if (gameState.currentPlayerIndex === player.id && Math.random() > 0.4) {
                                        aiLockInCard(player);
                                    } else {
                                        endTurn();
                                    }
                                }, 2000); // 2 second delay before lock-in decision
                            }, 2000); // 2 second delay before burning
                            return;
                        }
                    }
                }
                
                // AI decides whether to lock in a card
                if (Math.random() > 0.3) {
                    aiLockInCard(player);
                } else {
                    endTurn();
                }
            }, 2500); // 2.5 second initial delay
        }

        function aiBurnCard(player) {
            // AI burns worst card (with 2 second delay to make it visible)
            setTimeout(() => {
                const worstCard = player.hand.reduce((worst, card) => card.ovr < worst.ovr ? card : worst);
                gameState.selectedCard = worstCard;
                gameState.selectedCardPlayer = player.id;
                confirmBurn();
            }, 2000);
        }

        function aiLockInCard(player) {
            // AI picks best card considering bonuses
            if (player.hand.length === 0) {
                endTurn();
                return;
            }
            
            let bestScore = -Infinity;
            let bestCard = null;
            let bestPos = null;
            
            player.hand.forEach(card => {
                POSITIONS.forEach(pos => {
                    if (!player.lineup[pos] && canPlaceCardAtPosition(card, pos)) {
                        const bonuses = calculatePotentialBonuses(player, card);
                        const penalty = calculatePositionPenalty(card, pos);
                        const score = card.ovr + bonuses.total - penalty;
                        if (score > bestScore) {
                            bestScore = score;
                            bestCard = card;
                            bestPos = pos;
                        }
                    }
                });
            });
            
            if (bestCard && bestPos) {
                gameState.selectedCard = bestCard;
                gameState.selectedCardPlayer = player.id;
                placeCardInPosition(player.id, bestPos);
            } else {
                endTurn();
            }
        }

        function updatePhaseText() {
            const phaseMap = {
                'setup': 'Setup',
                'captainSelection': 'Captain Selection',
                'playing': 'Playing',
                'final': 'Game Over'
            };
            document.getElementById('phaseText').textContent = phaseMap[gameState.phase] || gameState.phase;

            let instructionText = '';
            
            if (gameState.phase === 'captainSelection') {
                const allCaptainsSet = gameState.players.every(p => p.captain);
                const allCaptainsPlaced = gameState.players.every(p => 
                    Object.values(p.lineup).some(card => card === p.captain)
                );
                
                if (!allCaptainsSet) {
                    instructionText = 'Select a card from your hand, click "Set Captain", then click a position slot to place it';
                } else if (!allCaptainsPlaced) {
                    instructionText = 'All captains selected. Click a position slot to place your captain.';
                } else {
                    instructionText = 'All captains placed. Starting game...';
                }
            } else if (gameState.phase === 'playing') {
                if (gameState.waitingForBurn !== null) {
                    const burningPlayer = gameState.players[gameState.waitingForBurn];
                    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                    
                    if (gameState.waitingForBurn === gameState.currentPlayerIndex) {
                        // Current player needs to burn (after asking for position)
                        instructionText = `${burningPlayer.name}, select a card from your hand and click "Burn Card", then you can lock in a card or end your turn`;
                    } else {
                        // Another player needs to burn (after someone locked in a card)
                        instructionText = `${burningPlayer.name}, select a card and click "Burn Card". Then ${currentPlayer.name}'s turn continues.`;
                    }
                } else {
                    const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                    instructionText = `${currentPlayer.name}'s turn - Ask for a position or select a card and click a position slot to lock it in`;
                }
            }
            
            document.getElementById('instructionText').textContent = instructionText;
        }

        function showModal(title) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modal').classList.add('show');
        }

        function closeModal() {
            document.getElementById('modal').classList.remove('show');
        }
    </script>

    <!-- Firebase CDN (Uncomment these when setting up online multiplayer) -->
    <!--
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script>
    // Firebase configuration (replace with your own from Firebase Console)
    const firebaseConfig = {
        apiKey: "YOUR_API_KEY",
        authDomain: "YOUR_PROJECT.firebaseapp.com",
        databaseURL: "https://YOUR_PROJECT.firebaseio.com",
        projectId: "YOUR_PROJECT",
        storageBucket: "YOUR_PROJECT.appspot.com",
        messagingSenderId: "YOUR_SENDER_ID",
        appId: "YOUR_APP_ID"
    };
    firebase.initializeApp(firebaseConfig);
    </script>
    -->
</body>
</html>
